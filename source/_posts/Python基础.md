---
title: Python基础
date: 2020-07-19 11:30:06
tags: 
- python
- 计算机科学课程
categories: 
- 计算机科学课程
- Prerequisites
- Python基础
keywords: 
- python
- 计算机科学课程
description: 从本篇笔记开始利用周末时间学习计算机科学课程，预计需要两年时间，且行且珍惜，加油努力！
cover: /2020/07/19/Python基础/Python基础首页.jpg
---

{% note info %}
```Text
--头部属性说明：
title	【必需】文章标题【需要】
date	【必需】文章创建日期【需要】
tags	【可选】文章标签【需要】
categories	【可选】文章分类【需要】
keywords	【可选】文章关键字【需要，同标签】
description	【可选】文章描述【需要】
top_img	【可选】文章顶部图片
cover	【可选】文章缩略图(如果没有设置top_img,文章页顶部将显示缩略图，可设为false/图片地址/留空)【需要，地址为：/年/月/日/文章标题/图片名称.后缀名】
comments	【可选】显示文章评论模块(默认 true)
toc	【可选】显示文章TOC(默认为设置中toc的enable配置)
toc_number	【可选】显示
toc_number	(默认为设置中toc的number配置)
copyright	【可选】显示文章版权模块(默认 true)
mathjax	【可选】显示mathjax(当设置mathjax的per_page: false时，才需要配置，默认 false)
katex	【可选】显示katex(当设置katex的per_page: false时，才需要配置，默认 false)

--标签外挂
样式：
[class] : default | primary | success | info | warning | danger.
{% note info %}
编辑内容
{% endnote %}

--图片插入示例：
不显示描述，可以插入【舍弃不用】：
{% asset_img example.png %}
显示描述的：
![example](example.png)	不用添加路径，直接填图片名称即可，将图片放入对应文件夹内

-- 插入链接
{% link text url [external] [title] %}

```
{% endnote %}
# 第一章 前言
主要是参考尚硅谷的李立超老师的Python基础视频笔记，加上自己的所总结的知识点，形成比较完善的python笔记，方便自己后续查阅已经复习巩固资料。

# 第二章 计算机基础知识
{% note default %}
该章比较基础，可有可无，当做扩展资料。
{% endnote %}
## 计算机是什么
在现实生活中，越来越无法离开计算机了
  电脑、笔记本、手机、游戏机、汽车导航、智能电视 。。。
计算机就是一个用来计算的机器！
目前来讲，计算机只能根据人类的指令来完成各种操作，人让它干嘛他就得干嘛
所以我们学习计算机，就是学习如何控制计算机！

## 计算机的组成
计算机由两部分组成：硬件 和 软件
硬件包含：键盘、鼠标、显示器、CPU、主板、内存、硬盘 。。。
   硬件是看的见摸得着的
  软件包含：系统软件（windows、macOS、Linux）和应用软件（office 、QQ、绝地求生）
   软件是看的见摸不着的，软件负责控制计算机中的硬件    

## 计算机的使用方式
我们必须要通过软件来对计算机完成各种操作，
   但是注意，软件中并不是所有的功能都会对用户开放，
   用户需要调用软件提供的接口（Interface 交互界面）来操作计算机
    
用户界面分成两种：TUI（文本交互界面）和 GUI（图形化交互界面）

## windows的命令行
命令行就是文本交互界面，通过命令行可以使用一个一个的指令来操作计算机
任何的计算机的操作系统中都包含有命令行（windows、linux、macOS）
命令行有多个不同的名字：
   命令行、命令行窗口、DOS窗口、命令提示符、CMD窗口、Shell、终端、Terminal
1.如何进入到命令行
   win键 + R 出现运行窗口，输入cmd，然后回车
2.命令行的结构
 - 版本及版权声明（一般没有什么用）
   Microsoft Windows [版本 10.0.16299.431]
   (c) 2017 Microsoft Corporation。保留所有权利。
   
 - 命令提示符
    C:\Users\lilichao>  
    C:  
 - 当前所在的磁盘根目录
 - 可以通过 x: 来切换盘符（x表示你的盘符）
   
    \Users\lilichao
     - 所在磁盘的路径，当前所在的文件夹
     - cd 来切换目录
    \>
     - 命令提示符，在大于号后边可以直接输入指令
    

3.常用的dos命令
```
        dir 查看当前目录下的所有文件（夹）
        cd 进入到指定的目录
            . 表示当前目录
            .. 表示上一级目录
        md 创建一个目录
        rd 删除一个目录    
        del 删除一个文件
        cls 清除屏幕
    
		命令的语法
   			命令 [参数] [选项]
```
4.小技巧
  - 方向键上下，查看命令的历史记录
  - tab键自动补全命令        

## 环境变量（environment variable）
```
    环境变量指的就是操作系统当中的一些变量。
    可以通过修改环境变量，来对计算机进行配置（主要是来配置一些路径的）
    1.查看环境变量
        > 右键 计算机（此电脑），选择属性
        > 系统界面左侧选择 高级系统设置
        > 选择环境变量
        环境变量界面分成了两个部分，上边是用户环境变量，下边是系统环境变量
            建议只修改用户的环境变量，不要修改系统的环境变量
            {% note info %}
            必要时还是需要修改系统变量，具体问题具体分析
            {% endnote}
    
    2.添加环境变量
        > 通过新建按钮添加环境变量
        > 一个环境变量可以由多个值，值与值之间使用;（英文）隔开
    
    3.修改环境变量
        > 通过编辑按钮来修改环境变量
    
    4.删除环境变量
        > 通过删除按钮来删除环境变量    
```

## path环境变量
```
    path环境变量中保存的是一个一个的路径。
    当我们在命令行中输入一个命令（或访问一个文件时），
        系统会首先在当前目录下寻找，如果找到了则直接执行或打开
        如果没有找到，则会依次去path环境变量的路径中去寻找，直到找到为止
        如果path环境变量中的路径都没有找到，则报错
            'xxx' 不是内部或外部命令，也不是可运行的程序或批处理文件。
    我们可以将一些经常需要访问到的文件会程序的路径，添加到path环境变量中，
        这样我们就可以在任意的位置访问到这些文件了
    
    注意事项：
        1.如果环境变量中没有path，可以手动添加
        2.path环境变量不区分大小写 PATH Path path   
        3.修改完环境变量必须重新启动命令行窗口
        4.多个路径之间使用;隔开
```

## 进制
{% note primary %}
B：二进制
O：八进制
D：十进制
H：十六进制
{% endnote %}

- 十进制（最常用的进制）
	- 十进制就是满十进一的进制
	- 十进制当中一共有10个数字
            0 1 2 3 4 5 6 7 8 9
    - 十进制如何计数
            0 1 2 3 4 5 6 7 8 9 10 11 12 。。。 19 20 。。。29 30
  
- 二进制（计算机底层使用的进制）
    - 满二进一
    - 二进制中一共有2个数字
          0 1
    - 二进制如何计数
          0 1 10 11 100 101 110 111 1000
    - 所有的数据在计算机底层都是以二进制的形式保存的，计算机只认二进制
    - 可以将内存想象为一个一个的小格子，小格子中可以存储一个0或一个1
    - 内存中的每一个小格子，我们称为1bit（位）    
         bit是计算机中的最小的单位
         byte是我们最小的可操作的单位
         8bit = 1byte（字节）    
         1024byte = 1kb（千字节） 
         1024kb = 1mb（兆字节）
         1024mb = 1gb（吉字节）
         1024gb = 1tb（太字节）
         。。。


- 八进制（一般不用）
    - 满八进一
    - 八进制中一共有8个数字
        0 1 2 3 4 5 6 7
    - 八进制如何计数
        0 1 2 3 4 5 6 7 10 11 。。。 17 20 。。。27 30
    
- 十六进制
    - 满十六进一
    - 十六进制中一共有16个数字
         由于十六进制是满16才进位，
         所以十六进制中引入了a b c d e f来表示 10 11 12 13 14 15   
          0 1 2 3 4 5 6 7 8 9 a b c d e f 
    - 十六进制如何计数    
        0 1 2 3 4 5 6 7 8 9 a b c d e f 10 11 12 。。。 1a 1b 1c 1d 1e 1f
            20 21 22 。。。 2a 2b 2c 2d 2e 2f 30    
    - 我们在查看二进制数据时，一般会以十六进制的形式显示

## 进制转换
### 二进制数转换成十进制数
   由二进制数转换成十进制数的基本做法是，把二进制数首先写成加权系数展开式，然后按十进制加法规则求和。这种做法称为"按权相加"法。
   例1105 把二进制数110.11转换成十进制数。
   ![二进制转换十进制例子](1、二进制转换十进制例子.png)

### 、十进制数转换为二进制数
十进制数转换为二进制数时，由于整数和小数的转换方法不同，所以先将十进制数的整数部分和小数部分分别转换后，再加以合并。
    
- 十进制整数转换为二进制整数
    十进制整数转换为二进制整数采用"<font color=red size=3>`除2取余，逆序排列`</font>"法。具体做法是：用2去除十进制整数，可以得到一个商和余数；再用2去除商，又会得到一个商和余数，如此进行，直到商为零时为止，然后把先得到的余数作为二进制数的低位有效位，后得到的余数作为二进制数的高位有效位，依次排列起来。
    例1107 把 (173)10 转换为二进制数。
![十进制整数转换二进制](2、十进制整数转换二进制.png)

- 十进制小数转换为二进制小数
    十进制小数转换成二进制小数采用"乘2取整，顺序排列"法。具体做法是：用2乘十进制小数，可以得到积，将积的整数部分取出，再用2乘余下的小数 部分，又得到一个积，再将积的整数部分取出，如此进行，直到积中的小数部分为零，或者达到所要求的精度为止。
    然后把取出的整数部分按顺序排列起来，先取的整数作为二进制小数的高位有效位，后取的整数作为低位有效位。
    【例1108】把（0.8125）转换为二进制小数。
![十进制小数转换二进制](3、十进制小数转换二进制.png)

<font color=red size=3>
  例1109 （173.8125）10＝（ ）2
    解： 由［例1107］得（173）10＝（10101101）2
由［例1108］得（0.8125）10＝（0.1101）2
把整数部分和小数部分合并得： （173.8125）10＝（10101101.1101）2
</font>

十进制小数转换成二进制小数采用"乘2取整，顺序排列"法。具体做法是：用2乘十进制小数，可以得到积，将积的整数部分取出，再用2乘余下的小数部分，又 得到一个积，再将积的整数部分取出，如此进行，直到积中的整数部分为零，或者整数部分为1，此时0或1为二进制的最后一位。或者达到所要求的精度为止。
然后把取出的整数部分按顺序排列起来，先取的整数作为二进制小数的高位有效位，后取的整数作为低位有效位。
十进制小数转二进制
```shell
如：0.625=（0.101）B
0.625*2=1.25======取出整数部分1
0.25*2=0.5========取出整数部分0
0.5*2=1==========取出整数部分1

再如：0.7=（0.1 0110 0110...）B
0.7*2=1.4========取出整数部分1
0.4*2=0.8========取出整数部分0
0.8*2=1.6========取出整数部分1
0.6*2=1.2========取出整数部分1
0.2*2=0.4========取出整数部分0
0.4*2=0.8========取出整数部分0
0.8*2=1.6========取出整数部分1
0.6*2=1.2========取出整数部分1
0.2*2=0.4========取出整数部分0
```
## 文本文件和字符集

1. 文本分成两种，一种叫做纯文本，还有一种叫做富文本
2. 纯文本中只能保存单一的文本内容，无法保存内容无关的东西（字体、颜色、图片。。。）
3. 富文本中可以保存文本以外的内容（word文档）
4. 在开发时，编写程序使用的全都是纯文本！
5. 纯文本在计算机底层也会转换为二进制保存，
 - 将字符转换为二进制码的过程，我们称为编码
 - 将二进制码转换为字符的过程，我们称为解码
 - 编码和解码时所采用的规则，我们称为字符集
6. 常见的字符集：
 - ASCII
	- 美国人编码，使用7位来对美国常用的字符进行编码
	- 包含128个字符
 - ISO-8859-1
	- 欧洲的编码，使用8位
	- 包含256个字符
 - GB2312
 - GBK
	- 国标码，中国的编码
 - Unicode   
	- 万国码，包含世界上所有的语言和符号，编写程序时一般都会使用Unicode编码
	- Unicode编码有多种实现，UTF-8 UTF-16 UTF-32
	- 最常用的就是UTF-8
7. 乱码
- 编写程序时，如果发现程序代码出现乱码的情况，就要马上去检查字符集是否正确     

## Sublime Text 3

- 纯文本编辑器
- Package Control（Sublime的包管理器）
	- Sublime Text3中的插件，通过该插件可以向Sublime中安装新的包 

# 第三章 Python入门
## 什么是计算机语言
计算机就是一台用来计算机的机器，人让计算机干什么计算机就得干什么！
需要通过计算机的语言来控制计算机（编程语言）！
计算机语言其实和人类的语言没有本质的区别，不同点就是交流的主体不同！
计算机语言发展经历了三个阶段：
1. 机器语言
 - 机器语言通过二进制编码来编写程序
 - 执行效率好，编写起来太麻烦

2. 符号语言（汇编）
 - 使用符号来代替机器码
 - 编写程序时，不需要使用二进制，而是直接编写符号
 - 编写完成后，需要将符号转换为机器码，然后再由计算机执行
 - 符号转换为机器码的过程称为汇编
 - 将机器码转换为符号的过程，称为反汇编  
 - 汇编语言一般只适用于某些硬件，兼容性比较差  

3. 高级语言
 - 高级语言的语法基本和现在英语语法类似，并且和硬件的关系没有那么紧密了
 - 也就是说我们通过高级语言开发程序可以在不同的硬件系统中执行
 - 并且高级语言学习起来也更加的容易，现在我们知道的语言基本都是高级语言
 - C、C++、C#、Java、JavaScript、Python 。。。

## 编译型语言和解释型语言
计算机只能识别二进制编码（机器码），所以任何的语言在交由计算机执行时必须要先转换为机器码，
也就是像 print('hello') 必需要转换为类似 1010101 这样的机器码   

根据转换时机的不同，语言分成了两大类：
1. 编译型语言
 - C语言
 - 编译型语言，会在代码执行前将代码编译为机器码，然后将机器码交由计算机执行
 - a(源码) --编译--> b(编译后的机器码)
 - 特点：
	- 执行速度特别快
	- 跨平台性比较差

2. 解释型语言 
 - Python JS Java
 - 解释型语言，不会在执行前对代码进行编译，而是在执行的同时一边执行一边编译
 - a（源码）--解释器--> 解释执行  
 - 特点：
	- 执行速度比较慢
	- 跨平台性比较好   

## Python的介绍   
1. Python是解释型语言
2. Python（英国发音：/?pa?θ?n/ 美国发音：/?pa?θɑ?n/），是一种广泛使用的高级编程语言，属于通用型编程语言，由吉多·范罗苏姆创造，第一版发布于1991年。可以视之为一种改良（加入一些其他编程语言的优点，如面向对象）的LISP。作为一种解释型语言，Python的设计哲学强调代码的可读性和简洁的语法（尤其是使用空格缩进划分代码块，而非使用大括号或者关键词）。相比于C++或Java，Python让开发者能够用更少的代码表达想法。不管是小型还是大型程序，该语言都试图让程序的结构清晰明了。 
3. Life is short you need Python （人生苦短，我用Python）    

4. Python的用途：
 - WEB应用: Facebook 豆瓣 。。。
 - 爬虫程序
 - 科学计算
 - 自动化运维
 - 大数据（数据清洗）
 - 云计算
 - 桌面软件/游戏
 - 人工智能
 - 。。。     

## Python开发环境搭建
1. 开发环境搭建就是安装Python的解释器
2. Python的解释器分类：
 - CPython（官方）：用c语言编写的Python解释器
 - PyPy：用Python语言编写的Python解释器
 - IronPython：用.net编写的Python解释器
 - Jython：用Java编写的Python解释器

3. 步骤：
 - 下载安装包 python-3.6.5.exe
	- 3.x
	- 2.x    
 - 安装（傻瓜式安装） 
 - 打开命令行窗口，输入python 出现如下内容
{% note primary %}
Python 3.6.5 (v3.6.5:f59c0932b4, Mar 28 2018, 16:07:46) [MSC v.1900 32 bit (Intel)] on win32
Type "help", "copyright", "credits" or "license" for more information.
\>>>    
{% endnote %}

## Python的交互界面
1. 当我们通过命令行来输入Python，所进入到的界面就是Python的交互界面
结构：
 - 版本和版权声明：
	- Python 3.6.5 (v3.6.5:f59c0932b4, Mar 28 2018, 16:07:46) [MSC v.1900 32 bit (Intel)] on win32
	- Type "help", "copyright", "credits" or "license" for more information.

 - 命令提示符：
	- \>>>


2. 在命令提示符后可以直接输入Python的指令！输入完的指令将会被Python的解释器立即执行！

3. 安装Python的同时，会自动安装一个Python的开发工具IDLE，通过IDLE也可以进入到交互模式
但是不同的是，在IDLE中可以通过TAB键来查看语句的提示。
IDLE实际上就是一个交互界面，但是他可以有一些简单的提示，并且可以将代码保存

4. 交互模式只能你输入一行代码，它就是执行一行，所以他并不适用于我们日常的开发！ 
 - 仅可以用来做一些日常的简单的测试！   

5. 我们一般会将Python代码编写到一个py文件中，然后通过python指令来执行文件中的代码

6. 练习：
 - 自己尝试创建一个py文件，并向文件中写入python打印语句（print...） 
 - 然后执行该文件。
 - 如果你的系统的扩展名无法修改，请尝试自行baidu！

## Python和Sublime的整合
1.在Sublime中执行Python代码，ctrl + b 自动在Sublime内置的控制台中执行  
	这种执行方式，在某些版本的Sublime中对中文支持不好，并且不能使用input()函数

2.使用SublimeREPL来运行python代码    
	安装完成，设置快捷键，希望按f5则自动执行当前的Python代码
	{ "keys": ["f5"], "caption": "SublimeREPL:Python","command": "run_existing_window_command", "args":{"id": "repl_python_run","file": "config/Python/Main.sublime-menu"}},

## 基本语法
1. 在Python中严格区分大小写
2. Python中的每一行就是一条语句，每条语句以换行结束
3. Python中每一行语句不要过长（规范中建议每行不要超过80个字符）
 - "rulers":[80],
4. 一条语句可以分多行编写，多行编写时语句后边以\结尾  
5. Python是缩进严格的语言，所以在Python中不要随便写缩进  
6. 在Python中使用#来表示注释，#后的内容都属于注释，注释的内容将会被解释器所忽略
 - 我们可以通过注释来对程序进行解释说明，一定要养成良好的编写注释的习惯
 - 注释要求简单明了，一般习惯上#后边会跟着一个空格
7. 在使用变量之前，需要对其先赋值
8. 变量名可以包括字母、数字、下划线，但变量名不能以数字开头

## 常用操作符
### 除法
使用`/`精确除；
使用 `//`地板除法，即省略小数点后位数，保留整数 （向下取整）
### 幂运算：**
```python
3 ** 2  = 9;
5 ** 3 = 125;
```
### not 逻辑运算符
取相反
![优先级问题](7、优先级问题.png)

### 一些注意点
### 使用反斜杠
在路径字符串使用反斜杠，需要使用转义字符`\`，如下：
```python
str = 'C:\\row' ——> print(str) ——> C:\row
str = r'C:\row' ——> print(str) ——> C:\row   \\使用r来添加转义字符，只对反斜杠转义生效

\\如果路径末尾加上反斜杠，则不能使用r来自动添加反斜杠，可以如下使用
str = r'C:\row' + '\\'
```
### 三重引号
得到一个跨越多行的字符串，使用三重引号字符串，例如：
```python
str = '''我爱鱼C，
正如我爱小甲鱼，
他那噶几噶几
呱唧呱唧
呱唧呱唧的声音，
总缠绕于我的脑海，
久久不肯散去。。。。。
'''
```

## 对象（object）
- Python是一门面向对象的语言
- 一切皆对象！
- 程序运行当中，所有的数据都是存储到内存当中然后再运行的！
- 对象就是内存中专门用来存储指定数据的一块区域
- 对象实际上就是一个容器，专门用来存储数据
- 像我们之前学习的数值、字符串、布尔值、None都是对象
![一切皆对象](4、一切皆对象.png)

## 对象的结构
- 每个对象中都要保存三种数据
- id（标识）
	> id用来标识对象的唯一性，每一个对象都有唯一的id
	> 对象的id就相当于人的身份证号一样
	> 可以通过id()函数来查看对象的id
	> id是由解析器生成的，在CPython中，id就是对象的内存地址
	> 对象一旦创建，则它的id永远不能再改变

- type（类型）
	> 类型用来标识当前对象所属的类型
	> 比如：int str float bool 。。。
	> 类型决定了对象有哪些功能
	> 通过type()函数来查看对象的类型
	> Python是一门强类型的语言，对象一旦创建类型便不能修改


- value（值）
	> 值就是对象中存储的具体的数据
	> 对于有些对象值是可以改变的
	> 对象分成两大类，可变对象 不可变对象
		可变对象的值可以改变
		不可变对象的值不能改变，之前学习的对象都是不可变对象

![对象的结构](5、对象的结构.png)

## 可变对象与不可变对象
1. Python 在 heap 中分配的对象分成两类：可变对象和不可变对象。所谓可变对象是指，对象的内容是可变的，例如 list。而不可变的对象则相反，表示其内容不可变。
{% note primary %}
不可变对象 ：int，string，float，tuple   \--- 可理解为C中，该参数为值传递
可变对象   ：list，dictionary，set           \--- 可理解为C中，该参数为指针传递
{% endnote %}

2. 由于 Python 中的变量存放的是对象引用，所以对于不可变对象而言，尽管对象本身不可变，但变量的对象引用是可变的。
```python
#因为258是int对象，是不可变对象的。所以下面3个id的值都是一样的，最后一句的结果也是为True
#该代码最好在IDE工具下运行，在命令行会有不同结果
print(id(258))
a = 258
print(id(a))
b = 258
print(id(b))
print(a is b)
```
![不可变对象](10、不可变对象.png)

3. 可变对象：其对象的内容是可以变化的。当对象的内容发生变化时，变量的对象引用是不会变化的。
![可变对象](11、可变对象.png)

### 可变对象
- 每个对象中都保存了三个数据：
    - id（标识）
    - type（类型）
    - value（值）    

- 列表就是一个可变对象
    - a = [1,2,3]

- a[0] = 10 （改对象）
    - 这个操作是在通过变量去修改对象的值
    - 这种操作不会改变变量所指向的对象    
    - 当我们去修改对象时，如果有其他变量也指向了该对象，则修改也会在其他的变量中体现

- a = [4,5,6] （改变量）
    - 这个操作是在给变量重新赋值
    - 这种操作会改变变量所指向的对象
    - 为一个变量重新赋值时，不会影响其他的变量

- 一般只有在为变量赋值时才是修改变量，其余的都是修改对象
    
### 从数据类型角度理解
1. 构造操作:  这类操作主要是基于一些已知信息，产生这个类的实例对象。类似银行进行开通账户  
 
2. 解析操作：这类操作是获取对象的一些有用信息，其结果反应了对象的一些特征，但返回的不是对象本身。类似银行查询账户余额   

3. 变化操作 ：这类操作是修改对象内部的信息和状态。比如一个银行账户进行转账操作

{% note default %}
如果一个类型，具只具有1和2两种操作，也就说只具有构造和解析操作，那么这个类型就是不可变类型，这个类型的对象就是不可变对象
如果一个类型，具有1、2、3三种操作，这个类型就是可变类型，这个类型的对象就是可变对象。
{% endnote %}

## 变量和对象
- 对象并没有直接存储到变量中，在Python中变量更像是给对象起了一个别名
- 变量中存储的不是对象的值，而是对象的id（内存地址），
	- 当我们使用变量时，实际上就是在通过对象id在查找对象
- 变量中保存的对象，只有在为变量重新赋值时才会改变
- 变量和变量之间是相互独立的，修改一个变量不会影响另一个变量

![变量与对象](6、变量与对象.png)

## 类型转换
1. 所谓的类型转换，将一个类型的对象转换为其他对象
2. <font color=red size=3>**类型转换不是改变对象本身的类型，而是根据当前对象的值创建一个新对象**</font>

3. 类型转换四个函数 int() float() str() bool()
4. <font color=red size=3>**type(变量名)可以查看变量的类型**</font>

### int()和float()
1. int() 可以用来将其他的对象转换为整型
2. 规则：
 - 布尔值：True -> 1   False -> 0
 - 浮点数：直接取整，省略小数点后的内容
 - 字符串：合法的整数字符串，直接转换为对应的数字
	- 如果不是一个合法的整数字符串，则报错 ValueError: invalid literal for int() with base 10: '11.5'
 - 对于其他不可转换为整型的对象，直接抛出异常 ValueError
3. float() 和 int()基本一致，不同的是它会将对象转换为浮点数

### str()和bool()
1. str() 可以将对象转换为字符串
 - True -> 'True'
 - False -> 'False'
 - 123 -> '123' 
 - 。。。

2. bool() 可以将对象转换为布尔值，任何对象都可以转换为布尔值
 - 规则：对于所有表示空性的对象都会转换为False，其余的转换为True
 - 哪些表示的空性：0 、 None 、 '' 。。。

### 例子说明
a = True

 - 调用int()来将a转换为整型
 int(a)  这里a的类型及值都没有发生改变
 - int()函数不会对原来的变量产生影响，他是对象转换为指定的类型并将其作为返回值返回
 - 如果希望修改原来的变量，则需要对变量进行重新赋值
a = int(a)

# 第四章 流程控制语句
{% note primary %}
- 缩进有两种方式，一种是使用tab键，一种是使用空格（四个）
    - Python的官方文档中推荐我们使用空格来缩进
    - 在sublime text中可以设置："translate_tabs_to_spaces": true
    
{% endnote %}
## 条件分支
```python
if 条件：
    条件为true执行的操作
else：
    条件为false执行的操作
  
#if-else例子
age = 7
if age > 17 :
    print('你已经成年了~~')
else :
    print('你还未成年~~')
    
#if-elif-else例子
age = 68

if age >= 18 and age < 30 :
    print('你已经成年了！')
elif age >= 30 and age < 60 :
    print('你已经中年了！')
else :
    print('你已经退休了！')

```
## 循环

### while循环
```python
while 条件：
    条件为true执行的操作
else :
    while条件为false执行的操作，为可选择关键词
    
    
#while例子
>>> i = 0
>>> while i < 10:
...     i += 1
...     print(i,'hello')
... else :
...     print('else中的代码块')
...
1 hello
2 hello
3 hello
4 hello
5 hello
6 hello
7 hello
8 hello
9 hello
10 hello
else中的代码块
```

### for循环
```python
    for 目标 in 表达式：
        循环体
```

## 条件表达式（三元操作符）
```python
x,y = 4,5
if x < y:
    small = x
else:
    small = y
    
#改为如下：
small = x if x < y else y
```

## break和continue
1. break: break可以用来立即退出循环语句（包括else）
2. continue: continue可以用来跳过当次循环
3. break和continue都是只对离他最近的循环起作用
4. pass: pass是用来在判断或循环语句中占位的,无实际意义

## assert ：断言
如果错误会自动抛出AssertionError异常

# 第五章 序列
## 列表:一个打了激素的数组

{% note primary %}
由于python中变量没有数据类型，所以python中用列表替代数组
{% endnote %}

1. 列表是Python中的一个对象
2. 对象（object）就是内存中专门用来存储数据的一块区域
3. 之前我们学习的对象，像数值，它只能保存一个单一的数据
4. 列表中可以保存多个有序的数据
5. 列表是用来存储对象的对象
6. 列表的使用：
 - 列表的创建
 - 操作列表中的数据

```python

# 创建列表，通过[]来创建列表
>>> my_list = [] # 创建了一个空列表
>>> print(my_list , type(my_list))
[] <class 'list'>

# 当向列表中添加多个元素时，多个元素之间使用,隔开
>>> member = ['红色','黑夜','迷途',‘蔡贤权','旭方']
>>> member
['红色','黑夜','迷途',‘蔡贤权','旭方']

#列表嵌套列表
>>> mix = [1,'红色',3.14,[1,2,3]]
>>> mix
[1,'红色',3.14,[1,2,3]]

# 列表中可以保存任意的对象
>>> my_list = [10,'hello',True,None,[1,2,3],print]
```

7. 列表中的对象都会按照插入的顺序存储到列表中，
 - 第一个插入的对象保存到第一个位置，第二个保存到第二个位置
8. 我们可以通过索引（index）来获取列表中的元素
 - 索引是元素在列表中的位置，列表中的每一个元素都有一个索引
 - 索引是从0开始的整数，列表第一个位置索引为0，第二个位置索引为1，第三个位置索引为2，以此类推
9. 索引访问list中每一个位置的元素：list名[n],从0开始；用-1做索引，直接获取最后一个元素
![索引访问列表](8、索引访问列表.png)

10. 追加元素到末尾，将元素插入到指定的位置
![插入到指定位置](9、插入到指定位置.png)

11. len（list名）：获得list元素的个数

12. extend(列表)：多个数据添加，以列表形式

```python
member.extend(['竹林小溪','Crazy迷恋'])
```

### 列表的方法
1. append()：向列表的最后添加一个元素
2. insert()：向列表的指定位置插入一个元素
 - 参数：1.要插入的位置；2.要插入的元素
3. extend()：使用新的序列来扩展当前序列，需要一个序列作为参数，它会将该序列中的元素添加到当前列表中
4. clear()：清空序列
5. pop()：根据索引删除并返回被删除的元素
6. remove()：删除指定值得元素，如果相同值得元素有多个，只会删除第一个
7. reverse(): 用来反转列表
7. sort()：用来对列表中的元素进行排序，默认是升序排列
 - 如果需要降序排列，则需要传递一个reverse=True作为参数
```python
>>> stus = ['孙悟空','猪八戒','沙和尚','唐僧']
>>> stus.append('唐僧')
>>> print(stus)
['孙悟空', '猪八戒', '沙和尚', '唐僧', '唐僧']

>>> stus.insert(2,'唐僧')
>>> print(stus)
['孙悟空', '猪八戒', '唐僧', '沙和尚', '唐僧', '唐僧']

>>> stus.extend(['唐僧','白骨精'])
>>> print(stus)
['孙悟空', '猪八戒', '唐僧', '沙和尚', '唐僧', '唐僧', '唐僧', '白骨精']

>>> stus += ['唐僧','白骨精']
>>> print(stus)
['孙悟空', '猪八戒', '唐僧', '沙和尚', '唐僧', '唐僧', '唐僧', '白骨精', '唐僧', '白骨精']

>>> stus.clear()
>>> print(stus)
[]

>>> stus = ['孙悟空','猪八戒','沙和尚','唐僧']
>>> result = stus.pop(2) # 删除索引为2的元素
>>> print('result = ',result)
result =  沙和尚
>>> result = stus.pop() # 删除最后一个
>>> print('result = ',result)
result =  唐僧
>>> print(stus)
['孙悟空', '猪八戒']

>>> stus.remove('猪八戒')
>>> print(stus)
['孙悟空']

>>> my_list = [10,1,20,3,4,5,0,-2]
>>> my_list.sort(reverse=True)
>>> print('修改后',my_list)
修改后 [20, 10, 5, 4, 3, 1, 0, -2]
```

### 遍历列表
```python
stus = ['孙悟空','猪八戒','沙和尚','唐僧','白骨精','蜘蛛精']
# 通过while循环来遍历列表
i = 0
while i < len(stus):
    print(stus[i])
    i += 1

# 通过for循环来遍历列表
# 语法：
#   for 变量 in 序列 :
#       代码块
# for循环的代码块会执行多次，序列中有几个元素就会执行几次
#   没执行一次就会将序列中的一个元素赋值给变量，
#   所以我们可以通过变量，来获取列表中的元素

for s in stus :
    print(s)
```

### 列表切片（slice）
```python
>>> member
['牡丹','黑夜','迷途','福禄娃娃']
>>> member[1,3]      #从1切到2，包含两个
['黑夜','迷途']
>>> member[:3] #从1切到2，包含三个
['牡丹','黑夜','迷途']
>>> member[:]  #相当于拷贝
['牡丹','黑夜','迷途','福禄娃娃']
  
  
  如果直接赋值，如下
>>> member1 = member
  这时，对member的任何修改，member1同样生效，相当于Linux中的硬连接
```

### 删除元素和修改元素
1. 列表名.remove('存储的值')：删除指定值
2. del 列表名[索引]：删除指定索引位置所在的值
3. del 列表名：删除这个列表
4. 列表名.pop()：删除最后一个元素
5. 列表名.pop(2): 删除指定位置的元素
6. pop(i)方法：删除指定位置的元素，i为索引位置
```python
>>> member.remove('蔡贤权')
>>> del member[1]
>>> del member \\删除这个列表
>>> member.pop()   \\删除最后一个元素
>>> member.pop(2)
```

7. 通过切片来修改列表和删除元素
 - 通过切片来修改列表，在给切片进行赋值时，只能使用序列
```python
>>> stus = ['孙悟空','猪八戒','沙和尚','唐僧','蜘蛛精','白骨精']
# 在给切片进行赋值时，只能使用序列
>>> stus[0:2] = ['牛魔王','红孩儿'] #使用新的元素替换旧元素
>>> print(stus)
['牛魔王', '红孩儿', '沙和尚', '唐僧', '蜘蛛精', '白骨精']

# 也可以多个元素来替换之前的元素
>>> stus[0:2] = ['牛魔王','红孩儿','二郎神']
>>> print(stus)
['牛魔王', '红孩儿', '二郎神', '沙和尚', '唐僧', '蜘蛛精', '白骨精']

>>> stus[0:0] = ['铁扇公主'] #向索引为0的位置插入元素
>>> print(stus)
['铁扇公主', '牛魔王', '红孩儿', '二郎神', '沙和尚', '唐僧', '蜘蛛精', '白骨精']

# 当设置了步长时，序列中元素的个数必须和切片中元素的个数一致
>>> stus[::2]
['铁扇公主', '红孩儿', '沙和尚', '蜘蛛精']
>>> stus[::2] = ['牛魔王','红孩儿','二郎神'] #这里会报错，由于切片选取出来是四个，而序列中只有三个
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: attempt to assign sequence of size 3 to extended slice of size 4

```
 - 通过切片来删除元素
```python
>>> print(stus)
['铁扇公主', '牛魔王', '红孩儿', '二郎神', '沙和尚', '唐僧', '蜘蛛精', '白骨精']
>>> del stus[0:2]
>>> print(stus)
['红孩儿', '二郎神', '沙和尚', '唐僧', '蜘蛛精', '白骨精']
>>> del stus[::2]
>>> print(stus)
['二郎神', '唐僧', '白骨精']
>>> stus[1:3] = []
>>> print(stus)
['二郎神']
```

{% note primary %}
<font color=red size=3>**以上操作，只适用于可变序列**</font>
```python
>>> s = 'hello'
>>> s[1] = 'a' #不可变序列，无法通过索引来修改
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'str' object does not support item assignment

# 可以通过 list() 函数将其他的序列转换为list
>>> s = list(s)
>>> print(s)
['h', 'e', 'l', 'l', 'o']
```
{% endnote %}


## 通用操作(序列)
### + 和 *

- “+”可以将两个列表拼接为一个列表
- “*”可以将列表重复指定的次数
```python
>>> my_list = [1,2,3] * 5
>>> my_list
[1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]
```

### in 和 not in
- in用来检查指定元素是否存在于列表中，如果存在，返回True，否则返回False
- not in用来检查指定元素是否不在列表中，如果不在，返回True，否则返回False
```python
>>> stus = ['孙悟空','猪八戒','沙和尚','唐僧','蜘蛛精','白骨精','沙和尚','沙和尚']
>>> print('牛魔王' not in stus)
True
>>> print('牛魔王' in stus)
False
```

### ==、!=、is、is not
1. ==、!= 比较的是对象的值是否相等 
2. is、is not 比较的是对象的id是否相等（比较两个对象是否是同一个对象）
```python
>>> a = [1,2,3]
>>> b = [1,2,3]
>>> print(a,b)
[1, 2, 3] [1, 2, 3]
>>> print(id(a),id(b))
1962841246920 1962841246792
>>> print(a == b) # a和b的值相等，使用==会返回True
True
>>> print(a is b) # a和b不是同一个对象，内存地址不同，使用is会返回False
False
```

### len()、min()和max()
- len() 获取列表中的元素的个数
- min() 获取列表中的最小值
- max() 获取列表中的最大值
```python
>>> arr = [10,1,2,5,100,77]
>>> print(min(arr),max(arr),len(arr))
1 100 6
```

### 一些常见的方法
1. index()：取索引
2. count()：统计次数
3. reversed()：生成一个迭代器，强制转换为list显示
4. enumerate()：增加序号
5. zip()：拉链表
```python
>>> stus = ['孙悟空','猪八戒','沙和尚','唐僧','蜘蛛精','白骨精','沙和尚','沙和尚']

#获取指定元素在列表中的第一次出现时索引
>>> print(stus.index('沙和尚'))
2

#index()的第二个参数，表示查找的起始位置，第三个参数，表示查找的结束位置
>>> print(stus.index('沙和尚',3,7))
6

# count()统计指定元素在列表中出现的次数
>>> print(stus.count('牛魔王'))
0

#reversed()：生成一个迭代器，强制转换为list显示
>>> numbers = [1,18,13,0,-98,34,54,76,32]
>>> list(reversed(numbers))
[32, 76, 54, 34, -98, 0, 13, 18, 1]

#enumerate()：增加序号
>>> list(enumerate(numbers))
[(0, 1), (1, 18), (2, 13), (3, 0), (4, -98), (5, 34), (6, 54), (7, 76), (8, 32)]

#zip()：拉链表
>>> a = [1,2,3,4,5,6,7,8]
>>> b = [4,5,6,7,8]
>>> list(zip(a,b))
[(1, 4), (2, 5), (3, 6), (4, 7), (5, 8)]
```

### range()
range()是一个函数，可以用来生成一个自然数的序列
 - 该函数需要三个参数
    - 起始位置（可以省略，默认是0）
    - 结束位置【不包含边界位置】
    - 步长（可以省略，默认是1）
```pyton
r = range(5) # 生成一个这样的序列[0,1,2,3,4]
r = range(0,10,2)
r = range(10,0,-1) #从10开始，往0开始生成，[10,9,8,7,6,5,4,3,2,1]

>>> for s in 'hello':
...     print(s)
...
h
e
l
l
o
```

## 序列（sequence）
{% note primary %}
即对列表、元组、字符串的内置函数的操作
{% endnote %}

1. 序列是Python中最基本的一种数据结构
2. 数据结构指计算机中数据存储的方式
3. 序列用于保存一组有序的数据，所有的数据在序列当中都有一个唯一的位置（索引）
 - 并且序列中的数据会按照添加的顺序来分配索引
4. 序列的分类：
 - 可变序列（<font color=red size=3>**序列中的元素可以改变**</font>）：
    - \> 列表（list）
 - 不可变序列（<font color=red size=3>**序列中的元素不能改变**</font>）：
    - \> 字符串（str）    
    - \> 元组（tuple）
 - 刚刚我们所讲所有操作都是序列的通用操作01 02 03 三个文件中的操作
 
5. 列表、元组和字符串的共同点：
 - 都可以通过索引得到每一个元素
 - 默认索引值总是从0开始
 - 可以通过分片的方法得到一个范围内的元素的集合
 - 有很多共同的操作符（重复操作符、拼接操作符、成员关系操作符）

{% note primary %}
迭代：迭代是重复反馈过程的活动，其目的通常是为了逼近所需目标或结果。每一次对过程的重复称为一次“迭代”，而每一次迭代得到的结果会作为下一次迭代的初始值。
 ---百度百科
{% endnote %}

## 元组：戴上了枷锁的列表
1. 元组是一个不可变的序列
2. 它的操作的方式基本上和列表是一致的
3. 所以你在操作元组时，就把元组当成是一个不可变的列表就ok了
4. 一般当我们希望数据不改变时，就使用元组，其余情况都使用列表
```python
# 创建元组
# 使用()来创建元组
>>> my_tuple = () # 创建了一个空元组
>>> print(my_tuple,type(my_tuple))
() <class 'tuple'>

>>> my_tuple = (1,2,3,4,5) # 创建了一个5个元素的元组

# 元组是不可变对象，不能尝试为元组中的元素重新赋值
>>> my_tuple[3] = 10
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment

#获取元组中的元素
>>> print(my_tuple[3])
4

# 当元组不是空元组时，括号可以省略
# 如果元组不是空元组，它里边至少要有一个逗号“,”，否则按数学公式中的小括号表示，即只是一个数值
>>> my_tuple = 10,20,30,40
>>> my_tuple = 40,
>>> print(my_tuple,type(my_tuple))
(40,) <class 'tuple'>

# 元组的解包（解构）
# 解包指就是将元组当中每一个元素都赋值给一个变量
>>> my_tuple = 10,20,30,40
>>> a,b,c,d = my_tuple
>>> print("a =",a)
a = 10
>>> print("b =",b)
b = 20
>>> print("c =",c)
c = 30
>>> print("d =",d)
d = 40

>>> a = 100
>>> b = 300
>>> print(a , b)
100 300

# 交互a 和 b的值，这时我们就可以利用元组的解包
>>> a , b = b , a
>>> print(a , b)
300 100

# 在对一个元组进行解包时，变量的数量必须和元组中的元素的数量一致
# 也可以在变量前边添加一个*，这样变量将会获取元组中所有剩余的元素
# 不能同时出现两个或以上的*变量
>>> my_tuple = 10 , 20 , 30 , 40
>>> a , b , *c = my_tuple
>>> print(type(c))
<class 'list'>
>>> print(c)
[30, 40]

#*号放在中间变量也是可以取值
>>> a , *b , c = my_tuple
>>> print(b)
[20, 30]

>>> *a , *b , c = my_tuple
  File "<stdin>", line 1
SyntaxError: two starred expressions in assignment

#也可以作用于字符串
>>> a , b , *c = 'hello world'
>>> print(type(c))
<class 'list'>
```

## 字符串

### 格式化字符串
1. 如果将两个字符串进行相加，则会自动将两个字符串拼接为一个
```python
>>> a = 'abc' + 'haha' + '哈哈'
>>> a
'abchaha哈哈'
```

2. 在创建字符串时，可以在字符串中指定占位符
 - %s 在字符串中表示任意字符
 - %f 浮点数占位符
 - %d 整数占位符
 
```python
>>> b = 'Hello %s'%'孙悟空'
>>> b
'Hello 孙悟空'
>>> b = 'hello %s 你好 %s'%('tom','孙悟空')
>>> b
'hello tom 你好 孙悟空'
>>> b = 'hello %3.5s'%'abcdefg' # %3.5s字符串的长度限制在3-5之间
>>> b
'hello abcde'
>>> b = 'hello %s'%123.456
>>> b
'hello 123.456'
>>> b = 'hello %.2f'%123.456
>>> b
'hello 123.46'
>>> b = 'hello %d'%123.95
>>> b
'hello 123'
>>> a = 123
>>> print('a = %s'%a)
a = 123
```

### 复制字符串
```python
# 字符串的复制（将字符串和数字相乘）
>>> a = 'abc'
# * 在语言中表示乘法
# 如果将字符串和数字相乘，则解释器会将字符串重复指定的次数并返回
>>> a = a * 20
>>> a
'abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc'
```

## 字典当索引不好用时（映射类型）
1. 字典属于一种新的数据结构，称为映射（mapping）
2. 字典的作用和列表类似，都是用来存储对象的容器
3. <font color=red size=3>**列表**</font>存储数据的性能很好，但是查询数据的性能的很差
4. 在字典中每一个元素都有一个唯一的名字，通过这个唯一的名字可以快速的查找到指定的元素
5. 在查询元素时，字典的效率是非常快的
6. 在字典中可以保存多个对象，每个对象都会有一个唯一的名字
 - 这个唯一的名字，我们称其为键（key），通过key可以快速的查询value
 - 这个对象，我们称其为值（value）
 - 所以字典，我们也称为叫做键值对（key-value）结构
 - 每个字典中都可以有多个键值对，而每一个键值对我们称其为一项（item）
 
### 创建字典
- 创建一个保护有数据的字典
- 语法：
    - {key:value,key:value,key:value}
    - 字典的值可以是任意对象
    - 字典的键可以是任意的不可变对象（int、str、bool、tuple ...），但是一般我们都会使用str
    - 字典的键是不能重复的，如果出现重复的后边的会替换到前边的
- 使用dict函数创建字典【<font color=red size=3>**关键字参数创建字典时key值不能有引号，key都是字符串**</font>】
- 使用fromkeys()内建字典

```python
# 使用 {} 来创建字典
>>> d = {} # 创建了一个空字典
>>> d
{}

#使用dict函数创建字典
#这个含义是将一个包含有双值子元组或子序列的元组或序列转换为字典

>>> dict3 = dict((('F',70),('i',105),('s',115),('h',104),('c',67)))
>>> dict3
{'F': 70, 'i': 105, 's': 115, 'h': 104, 'c': 67}
#注意：这里也可以传入字符串，但必须仅有两个字符
>>> dict4=dict([(1,2),['d',3],'ab',(4,5)])
>>> dict4
{1: 2, 'd': 3, 'a': 'b', 4: 5}

#参数传入的是key=value，一个括号就可以，key不能有引号，都是字符串类型
>>> dict4 = dict(蔡贤权 = '让编程改变世界', 苍井空 = '让AV征服所有宅男')
>>> dict4
{'蔡贤权': '让编程改变世界', '苍井空': '让AV征服所有宅男'}

#使用fromkeys()创建字典
>>> dict1 = {}
>>> dict1
{}
>>> dict1.fromkeys((1,2,3,4))
{1: None, 2: None, 3: None, 4: None}
>>> dict1.fromkeys((1,2,3,4),'Number')    #注意这里的第二个参数只能为一个，因为是将第二个参数的全部值赋予给每一个key
{1: 'Number', 2: 'Number', 3: 'Number', 4: 'Number'}
>>> dict1.fromkeys((1,2,3,4),('Number','caixianquan'))
{1: ('Number', 'caixianquan'), 2: ('Number', 'caixianquan'), 3: ('Number', 'caixianquan'), 4: ('Number', 'caixianquan')}
# 无法修改，试图修改时会重新创建一个字典
>>> dict1.fromkeys((1,3),'xufang')
{1: 'xufang', 3: 'xufang'}

# 重复值，后面替换前面
>>> d = {
... 'name':'孙悟空' ,
... 'age':18 ,
... 'gender':'男' ,
... 'name':'sunwukong'
... }
>>> print(d,type(d))
{'name': 'sunwukong', 'age': 18, 'gender': '男'} <class 'dict'>

# 需要根据键来获取值
>>> print(d['name'],d['age'],d['gender'])
sunwukong 18 男
# 如果使用了字典中不存在的键，会报错
>>> print(d['hello']) KeyError: 'hello'
  File "<stdin>", line 1
    print(d['hello']) KeyError: 'hello'
                             ^
SyntaxError: invalid syntax
```

### 使用字典
1. keys(): 该方法会返回字典的所有的key。返回一个序列，序列中保存有字典的所有的键
2. values(): 该方法会返回一个序列，序列中保存有字典的左右的值
3. items(): 该方法会返回字典中所有的项,返回一个序列，序列中包含有双值子序列。双值分别是，字典中的key和value
```python
>>> d = {'name':'孙悟空','age':18,'gender':'男'}

#通过遍历keys()来获取所有的键
>>> for k in d.keys() :
...     print(k , d[k])
...
name 孙悟空
age 18
gender 男

# 只获取字典中的值
>>> for v in d.values():
...     print(v)
...
孙悟空
18
男

#通过item获取key和value
>>> print(d.items())
dict_items([('name', '孙悟空'), ('age', 18), ('gender', '男')])
>>> for k,v in d.items() :
...     print(k , '=' , v)
...
name = 孙悟空
age = 18
gender = 男
```
4. len(): 获取字典中键值对的个数
5. in、not in: 检查字典中是否包含【不包含】指定的键
```python
>>> d = {'name':'孙悟空','age':18,'gender':'男'}
#获取字典中键值对的个数
>>> print(len(d))
3
>>> print('hello' in d) # in 检查字典中是否包含指定的键
False
```
6. get(key\[, default]): 该方法用来根据键来获取字典中的值,可以设定取不到时默认返回值
7. 修改字典：如果key存在则覆盖，不存在则添加
```python
#设置默认值
>>> d
{'name': '孙悟空', 'age': 18, 'gender': '男'}
>>> print(d.get('name'))
孙悟空
>>> print(d.get('hello'))
None
>>> print(d.get('hello','默认值'))
默认值

>>> d
{'name': '孙悟空', 'age': 18, 'gender': '男'}
>>> d['name'] = 'sunwukong' # 修改字典的key-value
>>> d['address'] = '花果山' # 向字典中添加key-value
>>> d
{'name': 'sunwukong', 'age': 18, 'gender': '男', 'address': '花果山'}
```
8. setdefault(key\[, default]): 可以用来向字典中添加key-value,<font color=red size=3>**不设置default默认为none**</font>
 - 如果key已经存在于字典中，则返回key的值，不会对字典做任何操作
 - 如果key不存在，则向字典中添加这个key，并设置value
```python
#setdefault()
>>> d
{'name': 'sunwukong', 'age': 18, 'gender': '男', 'address': '花果山'}
>>> result = d.setdefault('name')
>>> d
{'name': 'sunwukong', 'age': 18, 'gender': '男', 'address': '花果山'}
>>> result
'sunwukong'
>>> result = d.setdefault('hello')
>>> result
>>> d
{'name': 'sunwukong', 'age': 18, 'gender': '男', 'address': '花果山', 'hello': None}
```
9. update(\[other]): 将其他的字典中的key-value添加到当前字典中
 - 如果有重复的key，则后边的会替换到当前的
10. 删除: 可以使用 del 来删除字典中的 key-value
```python
#update()
>>> d = {'a':1,'b':2,'c':3}
>>> d2 = {'d':4,'e':5,'f':6, 'a':7}
>>> d.update(d2)
>>> d
{'a': 7, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6}

#del 删除
>>> d
{'a': 7, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6}
>>> del d['a']
>>> del d['b']
>>> d
{'c': 3, 'd': 4, 'e': 5, 'f': 6}
```
11. popitem(): 随机删除字典中的一个键值对，一般都会删除最后一个键值对
 - 删除之后，它会将删除的key-value作为返回值返回
 - 返回的是一个元组，元组中有两个元素，第一个元素是删除的key，第二个是删除的value
 - 当使用popitem()删除一个空字典时，会抛出异常 KeyError: 'popitem(): dictionary is empty'
12. pop(key\[, default]): 根据key删除字典中的key-value,会将被删除的value返回！
 - 如果删除不存在的key，会抛出异常。如果指定了默认值，再删除不存在的key时，不会报错，而是直接返回默认值
```python
#popitem() 随机删除字典中的一个键值对，一般删除最后一个键值对
>>> d
{'c': 3, 'd': 4, 'e': 5, 'f': 6}
>>> result = d.popitem()
>>> result
('f', 6)

#pop()，删除指定key
>>> d.pop('d')
4
>>> d.pop('z','这是默认值')
'这是默认值'
 ```
13. clear()用来清空字典, d.clear()
14. copy(): 该方法用于对字典进行浅复制
 - 复制以后的对象，和原对象是独立，修改一个不会影响另一个
 - 注意，<font color=red size=3>**浅复制会简单复制对象内部的值，如果值也是一个可变对象，这个可变对象不会被复制**</font>
```python
>>> d = {'a':1,'b':2,'c':3}
>>> d2 = d  #简单赋值，id一样
>>> print('d= ',d,id(d))
d=  {'a': 1, 'b': 2, 'c': 3} 1962841154616
>>> print('d2= ',d2,id(d2))
d2=  {'a': 1, 'b': 2, 'c': 3} 1962841154616
>>> d3 = d.copy() #浅复制，id不同
>>> print('d3= ',d3,id(d3))
d3=  {'a': 1, 'b': 2, 'c': 3} 1962841273400

#解释如果值也是一个可变对象，这个可变对象不会被复制
>>> d = {'a':{'name':'孙悟空','age':18},'b':2,'c':3}
>>> d2 = d.copy()
>>> d2['a']['name'] = '猪八戒'
>>> print('d = ',d , id(d))
d =  {'a': {'name': '猪八戒', 'age': 18}, 'b': 2, 'c': 3} 1962841155768
>>> print('d2 = ',d2 , id(d2))
d2 =  {'a': {'name': '猪八戒', 'age': 18}, 'b': 2, 'c': 3} 1962841272680
#可以看到值包含一个可变对象用到的是引用其地址，
所以对内部的可变对象赋值就会一起发生变化
```

## 集合
1. 集合和列表非常相似
2. 不同点：
 - 集合中只能存储不可变对象
 - 集合中存储的对象是无序（不是按照元素的插入顺序保存）
 - 集合中不能出现重复的元素
```python
# 使用 {} 来创建集合
>>> s = {10,3,5,1,2,1,2,3,1,1,1,1}
>>> type(s)
<class 'set'>
>>> s
{1, 2, 3, 5, 10}

#不能使用可变对象
>>> s = {[1,2,3],[4,6,7]}
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: unhashable type: 'list'
# 使用 set() 函数来创建集合
s = set() # 空集合
# 可以通过set()来将序列和字典转换为集合

>>> s = set([1,2,3,4,5,1,1,2,3,4,5])
>>> s
{1, 2, 3, 4, 5}
>>> s = set('hello')
>>> s
{'o', 'l', 'e', 'h'}

# 使用set()将字典转换为集合时，只会包含字典中的键
>>> s = set({'a':1,'b':2,'c':3})
>>> s
{'a', 'c', 'b'}
```
### 使用集合
1. 使用in和not in来检查集合中的元素
2. 使用len()来获取集合中元素的数量
```python
>>> s = {'a' , 'b' , 1 , 2 , 3 , 1}
>>> print('c' in s)
False
>>> print(len(s))
5
```
3. add(): 向集合中添加元素
```python
>>> s
{'a', 1, 2, 3, 'b'}
>>> s.add(10)
>>> s.add(30)
>>> s
{'a', 1, 2, 3, 'b', 10, 30}
```
4. update(): 将一个集合中的元素添加到当前集合中
 - update()可以传递序列或字典作为参数，字典只会使用键
```python
>>> s
{'a', 1, 2, 3, 'b', 10, 30}
>>> s2 = set('hello')
>>> s.update(s2)
>>> s
{'a', 1, 2, 3, 'l', 'b', 10, 'e', 'o', 'h', 30}
>>> s.update((10,20,30,40,50))
>>> s
{'a', 1, 2, 3, 'l', 'b', 40, 10, 'e', 'o', 50, 20, 'h', 30}
>>> s.update({10:'ab',20:'bc',100:'cd',1000:'ef'})
>>> s
{'a', 1, 2, 3, 'l', 100, 'b', 40, 1000, 10, 'e', 'o', 50, 20, 'h', 30}
```
5. pop()随机删除并返回一个集合中的元素
6. remove()删除集合中的指定元素
7. clear()清空集合
```python
>>> s
{'a', 1, 2, 3, 'l', 100, 'b', 40, 1000, 10, 'e', 'o', 50, 20, 'h', 30}
>>> s.pop()
'a'
>>> s.remove(100)
>>> s
{1, 2, 3, 'l', 'b', 40, 1000, 10, 'e', 'o', 50, 20, 'h', 30}
>>> s.clear()
>>> s
set()
```
### 集合的运算
<font color=red size=3>**在对集合做运算时，不会影响原来的集合，而是返回一个运算结果**</font>
```python
# 创建两个集合
s = {1,2,3,4,5}
s2 = {3,4,5,6,7}

# & 交集运算
result = s & s2 # {3, 4, 5}

# | 并集运算
result = s | s2 # {1,2,3,4,5,6,7}

# - 差集
result = s - s2 # {1, 2}

# ^ 异或集 获取只在一个集合中出现的元素
result = s ^ s2 # {1, 2, 6, 7}

# <= 检查一个集合是否是另一个集合的子集
# 如果a集合中的元素全部都在b集合中出现，那么a集合就是b集合的子集，b集合是a集合超集
a = {1,2,3}
b = {1,2,3,4,5}

result = a <= b # True
result = {1,2,3} <= {1,2,3} # True
result = {1,2,3,4,5} <= {1,2,3} # False

# < 检查一个集合是否是另一个集合的真子集
# 如果超集b中含有子集a中所有元素，并且b中还有a中没有的元素，则b就是a的真超集，a是b的真子集
result = {1,2,3} < {1,2,3} # False
result = {1,2,3} < {1,2,3,4,5} # True

# >= 检查一个集合是否是另一个的超集
# > 检查一个集合是否是另一个的真超集
print('result =',result)
```

# 第六章 函数
## 函数简介（function）
1. 函数也是一个对象
2. 对象是内存中专门用来存储数据的一块区域
3. 函数可以用来保存一些可执行的代码，并且可以在需要时，对这些语句进行多次的调用
4. 创建函数：
```python
def 函数名([形参1,形参2,...形参n]) :
    代码块
    
# 定义一个函数
def fn() :
    print('这是我的第一个函数！')
    print('hello')
    print('今天天气真不错！')
```
 - 函数名必须要符号标识符的规范
    - （可以包含字母、数字、下划线、但是不能以数字开头）    
5. 函数中保存的代码不会立即执行，需要调用函数代码才会执行
6. 调用函数：
 - 函数对象()
```python
# 打印fn
>>> print(fn)
<function fn at 0x000001C9023C2EA0>
>>> print(type(fn))
<class 'function'>

# fn是函数对象  fn()调用函数
# print是函数对象 print()调用函数
>>> fn()
这是我的第一个函数!
hello
今天天气真不错!
```
7. 定义函数一般都是要实现某种功能的    

## 函数的参数
1. 在定义函数时，可以在函数名后的()中定义数量不等的形参，
- 多个形参之间使用,隔开
2. 形参（形式参数），定义形参就相当于在函数内部声明了变量，但是并不赋值
3. 实参（实际参数）
 - 如果函数定义时，指定了形参，那么在调用函数时也必须传递实参，
    - 实参将会赋值给对应的形参，简单来说，有几个形参就得传几个实参
```python
>>> # 定义函数时指定形参
... def fn2(a , b) :
...     # print('a =',a)
...     # print('b =',b)
...     print(a,"+",b,"=",a + b)
...
>>> # 调用函数时，来传递实参
... fn2(10,20)
10 + 20 = 30
>>> fn2(123,456)
123 + 456 = 579
```
4. 默认形参：指定了默认值以后，如果用户传递了参数则默认值没有任何作用
 - 默认参数必须在无默认值的参数后面
```python
>>> def fn(a = 5 , b = 10 , c):
...     print('a =',a)
...     print('b= ',b)
...     print('c= ',c)
...
  File "<stdin>", line 1
SyntaxError: non-default argument follows default argument
>>> def fn(a , b = 10 , c = 20):
...     print('a =',a)
...     print('b= ',b)
...     print('c= ',c)
...
>>> fn(2)
a = 2
b=  10
c=  20
```
5. 位置参数和关键字参数：混合使用关键字和位置参数时，必须将位置参数写到前面
```python
>>> def fn(a , b = 10 , c = 20):
...     print('a =',a)
...     print('b= ',b)
...     print('c= ',c)
...
>>> fn(2,c = 30)
a = 2
b=  10
c=  30
```
6.  函数在调用时，解析器不会检查实参的类型。实参可以传递任意类型的对象
7. 形参传入的是一个对象，当通过形参去修改对象时会影响到所有指向该对象的变量
```python
>>> def fn4(a):
...     a[0] = 30
...     print('a =',a,id(a))
...
>>> c = [1,2,3]
>>> fn4(c)
a = [30, 2, 3] 1962841246856
#传入的是列表c的一个浅复制，并不会影响列表C中的值
>>> fn4(c.copy())   
a = [30, 2, 3] 1962841286408

#和以上一样，切片没指定开始和结束，即是浅复制
>>> fn4(c[:])
a = [30, 2, 3] 1962841286408
```

## 不定长的参数
{% note primary %}
在形参前边加上一个*，这样这个形参将会获取到所有的实参，
本质上是将获得的实参保存为一个元组，<font color=red size=3>**参考元组那一小节的赋值**</font>
{% endnote %}
```python
>>> def sum(*nums):
...     result = 0
...     for n in nums :
...         result += n
...     print(result)
...
>>> sum(123,456,789,10,20,30,40)
1468
```
1. 可变参数不是必须写在最后，但是注意，带*的参数后的所有参数，必须以关键字参数的形式传递
```python
# 第一个参数给a，剩下的位置参数给b的元组，c必须使用关键字参数
def fn2(a,*b,c):
    print('a =',a)
    print('b =',b)
    print('c =',c)
>>> fn2(23,453,54,c=21,65)
  File "<stdin>", line 1
SyntaxError: positional argument follows keyword argument
>>> fn2(23,453,54,c=21)
a = 23
b = (453, 54)
c = 21
>>> fn2(23,453,54)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: fn2() missing 1 required keyword-only argument: 'c'

# 所有的位置参数都给a，b和c必须使用关键字参数
def fn2(*a,b,c):
    print('a =',a)
    print('b =',b)
    print('c =',c)
    
# 如果在形参的开头直接写一个*,则要求我们的所有的参数必须以关键字参数的形式传递
def fn2(*,a,b,c):
    print('a =',a)
    print('b =',b)
    print('c =',c)
```
2. *形参只能接收位置参数，而不能接收关键字参数
```python
def fn3(*a) :
    print('a =',a)
```
3. \*\*形参可以接收其他的关键字参数，它会将这些参数统一保存到一个字典中
 - 字典的key就是参数的名字，字典的value就是参数的值
 - \*\*形参只能有一个，并且必须写在所有参数的最后
```python
>>> def fn3(b,c,**a) :
...     print('a =',a,type(a))
...     print('b =',b)
...     print('c =',c)
...
>>> fn3(b=1,d=2,c=3,e=10,f=20)
a = {'d': 2, 'e': 10, 'f': 20} <class 'dict'>
b = 1
c = 3
```
4. 参数的解包（拆包）
 - 传递实参时，也可以在序列类型的参数前添加星号，这样他会自动将序列中的元素依次作为参数传递
 - 要求序列中元素的个数必须和形参的个数的一致
```python
>>> def fn4(a,b,c):
...     print('a =',a)
...     print('b =',b)
...     print('c =',c)
...
>>> t = (10,20,30)
>>> fn4(*t)
a = 10
b = 20
c = 30

>>> def fn4(a,b,*c):
...     print('a =',a)
...     print('b =',b)
...     print('c =',c)
...
>>> t = (10,20,30,40)
>>> fn4(*t)
a = 10
b = 20
c = (30, 40)
```
5. 通过 \*\*来对一个字典进行解包操作
```python
>>> def fn4(a,b,c):
...     print('a =',a)
...     print('b =',b)
...     print('c =',c)
...
>>> d = {'a':100,'b':200,'c':(300,400)}
>>> fn4(**d)
a = 100
b = 200
c = (300, 400)
```

## 返回值
1. 关键字：return
2. return 可以返回一个函数
```python
>>> def fn():
...     def fn2():
...             print('hello')
...     return fn2
...
>>> r = fn() #使用变量保存一个函数对象，fn返回的是fn2这个函数对象
>>> r()
hello
```
3. 如果仅仅写一个return 或者 不写return，则相当于return None 

## 文档字符串
1. help()是Python中的内置函数
2. 通过help()函数可以查询python中的函数的用法
 - 语法：help(函数对象)
```python
help(print) # 获取print()函数的使用说明
```
3. 在定义函数时，可以在函数内部编写文档字符串，文档字符串就是函数的说明
4. 当我们编写了文档字符串时，就可以通过help()函数来查看函数的说明
```python
#对形参进行类型描述只是作为文档描述，实际不起作用，可以传入任何类型
>>> def fn(a:int,b:bool,c:str='hello') -> int:
...     '''
...     这是一个文档字符串的示例
...
...     函数的作用：。。。。。
...     函数的参数：
...         a，作用，类型，默认值。。。。
...         b，作用，类型，默认值。。。。
...         c，作用，类型，默认值。。。。
...     '''
...     return 10
...
>>> help(fn)
Help on function fn in module __main__:

fn(a:int, b:bool, c:str='hello') -> int
    这是一个文档字符串的示例

    函数的作用：。。。。。
    函数的参数：
        a，作用，类型，默认值。。。。
        b，作用，类型，默认值。。。。
        c，作用，类型，默认值。。。。
```

## 作用域与命名空间
### 作用域
1. 使用变量时，会优先在当前作用域中寻找该变量，如果有则使用
如果没有则继续去上一级作用域中寻找,以此类推
2. 在函数中为变量赋值时，默认都是为局部变量赋值
如果希望在函数内部修改全局变量，则需要使用global关键字，来声明变量
```python
>>> a = 20
>>> def fn3():
...     global a    #必须且只能是声明，不能直接赋值
...     a = 10
...     print('函数内部: ','a = ',a)
...
>>> fn3()
函数内部:  a =  10
>>> a
10
```

### 命名空间
1. locals(): 获取当前命名空间
2. globals(): 在任意位置获取全局命名空间
3. 不建议通过命名空间来修改变量值

## 递归
1. 递归是解决问题的一种方式，它和循环很像
 - 它的整体思想是，将一个大问题分解为一个个的小问题，直到问题无法分解时，再去解决问题
2. 递归式函数的两个要件
 - 基线条件
    - 问题可以被分解为的最小问题，当满足基线条件时，递归就不在执行了
 - 递归条件
    - 将问题继续分解的条件
```python
>>> def factorial(n):
...     if n == 1:
...             return 1
...     return n * factorial(n-1)
...
>>> factorial(5)
120
```
3. 递归深度: python3默认递归的深度为100层，可以修改递归深度
```python
>>> import sys
>>> sys.setrecursionlimit(1000000)      //设置递归的深度为100万层
```

# 第七章 高阶函数
## 高阶函数
1. 接收函数作为参数，或者将函数作为返回值的函数是高阶函数
```python
def fn(func, lst):
    new_list = []
    for n in lst :
            if func(n):
                new_list.append(n)
    return new_list


def fn4(i):
    return i % 3 == 0


l = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

print(fn(fn4, l))   #[3, 6, 9]
```
2. filter(): 可以从序列中过滤出符合条件的元素，保存到一个新的序列中
 - 参数：
    - 1.函数，根据该函数来过滤序列（可迭代的结构）
    - 2.需要过滤的序列（可迭代的结构）
 - 返回值：
    - 过滤后的新序列（可迭代的结构）
3. 匿名函数 lambda 函数表达式 （语法糖）
 - lambda函数表达式专门用来创建一些简单的函数，他是函数创建的又一种方式
 - 语法：lambda 参数列表 : 返回值
 - 匿名函数一般都是作为参数使用，其他地方一般不会使用
 - 可以将匿名函数赋值给一个变量，一般不会这么做
```python
>>> fn6 = lambda a,b : a + b
>>> print(fn6(10,30))
40

>>> l = [1,2,3,4,5,6,7,8,9,10]
>>> r = filter(lambda i : i > 5 , l)
>>> r
<filter object at 0x000001C902B049E8>
>>> print(list(r))
[6, 7, 8, 9, 10]
```
4. map(): 可以对可迭代对象中的所有元素做指定的操作，然后将其添加到一个新的对象中返回
```python
>>> l = [1,2,3,4,5,6,7,8,9,10]
# 对列表中的每个元素进行指数操作
>>> r = map(lambda i : i ** 2 , l)
>>> print(list(r))
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
```
5. sort(): 该方法用来对列表中的元素进行排序,默认是直接比较列表中的元素的大小
 - 在sort()可以接收一个关键字参数 ， key
    - key需要一个函数作为参数，当设置了函数作为参数
    - 每次都会以列表中的一个元素作为参数来调用函数，并且使用函数的返回值来比较元素的大小
```python
>>> l = ['bb','aaaa','c','ddddddddd','fff']
>>> l.sort(key=len)
>>> l
['c', 'bb', 'fff', 'aaaa', 'ddddddddd']
```
6. sorted(): 这个函数和sort()的用法基本一致，但是sorted()可以对任意的序列进行排序
 - 并且使用sorted()排序不会影响原来的对象，而是返回一个新对象
```python
>>> l = [2,5,'1',3,'6','4']
>>> print('排序前:',l)
排序前: [2, 5, '1', 3, '6', '4']
>>> print(sorted(l,key=int))
['1', 2, 3, '4', 5, '6']
>>> print('排序后:',l)
排序后: [2, 5, '1', 3, '6', '4']
```

## 闭包
1. 将函数作为返回值返回，也是一种高阶函数
2. 这种高阶函数我们也称为叫做闭包，通过闭包可以创建一些只有当前函数能访问的变量
3. 可以将一些私有的数据藏到的闭包中
4. 形成闭包的条件
 - 函数嵌套
 - 将内部函数作为返回值返回
 - 内部函数必须要使用到外部函数的变量
```python
def make_averager():
     nums = []
     def averager(n):
             nums.append(n)
             return sum(nums)/len(nums)
     return averager

averager = make_averager()
print(averager(10)) #10.0
```

## 装饰器
1. 开闭原则（OCP）: 程序的设计，要求开发对程序的扩展，要关闭对程序的修改
```python
def add(a, b):
    r = a + b
    return r


def begin_end(old):
    def new_function(*args, **kwargs):
        print('开始执行~~~~')
        result = old(*args, **kwargs)
        print('执行结束~~~~')
        return result
    return new_function


f = begin_end(add)
t = f(123, 456)
print(t)

#开始执行~~~~
#执行结束~~~~
#579#
```
2. 向begin_end()这种函数我们就称它为装饰器
 - 通过装饰器，可以在不修改原来函数的情况下来对函数进行扩展
 - 在开发中，我们都是通过装饰器来扩展函数的功能的
 - 在定义函数时，可以通过@装饰器，来使用指定的装饰器，来装饰当前的函数
 - 可以同时为一个函数指定多个装饰器，这样函数将会安装从内向外的顺序被装饰 
```python
def begin_end(old):
    def new_function(*args, **kwargs):
        print('开始执行~~~~')
        result = old(*args, **kwargs)
        print('执行结束~~~~')
        return result
    return new_function


def fn3(old):
    '''
        用来对其他函数进行扩展，使其他函数可以在执行前打印开始执行，执行后打印执行结束

        参数：
            old 要扩展的函数对象
    '''
 09        print('fn3装饰~开始执行~~~~')
        # 调用被扩展的函数
        result = old(*args , **kwargs)
        print('fn3装饰~执行结束~~~~')
        # 返回函数的执行结果
        return result

    # 返回新函数
    return new_function

@fn3
@begin_end
def say_hello():
    print('大家好~~~')

say_hello()

#打印结果
fn3装饰~开始执行~~~~
开始执行~~~~
大家好~~~
执行结束~~~~
fn3装饰~执行结束~~~~
```

# 第八章 对象（Object）
## 什么是对象？
1. 对象是内存中专门用来存储数据的一块区域。
2. 对象中可以存放各种数据（比如：数字、布尔值、代码）
3. 对象由三部分组成：
 - 对象的标识（id）
 - 对象的类型（type）
 - 对象的值（value）

## 类(class) 
- 我们目前所学习的对象都是Python内置的对象
- 但是内置对象并不能满足所有的需求，所以我们在开发中经常需要自定义一些对象
- 类，简单理解它就相当于一个图纸。在程序中我们需要根据类来创建对象
- 类就是对象的图纸！
- 我们也称对象是类的实例（instance）
- 如果多个对象是通过一个类创建的，我们称这些对象是一类对象
- 像 int() float() bool() str() list() dict() .... 这些都是类
- a = int(10) # 创建一个int类的实例 等价于 a = 10
- 我们自定义的类都需要使用大写字母开头，使用大驼峰命名法（帕斯卡命名法）来对类命名
- 类也是一个对象！
- 类就是一个用来创建对象的对象！
- 类是type类型的对象，定义类实际上就是定义了一个type类型的对象

### 类的简单使用
1. isinstance(): 用来检查一个对象是否是一个类的实例
```python
#定义一个类
class MyClass():
    pass
    
# 使用类来创建对象，就像调用一个函数一样
mc = MyClass() # mc就是通过MyClass创建的对象，mc是MyClass的实例

#检查mc对象是否是MyClass类的一个实例
result = isinstance(mc,MyClass)

#现在通过MyClass这个类创建的对象都是一个空对象，
#可以向对象中添加变量，对象中的变量称为属性
#语法：对象.属性名 = 属性值
mc.name = '孙悟空'

print(mc.name)  #孙悟空
```

### 类的定义
1. 类对象和实例对象中都可以保存属性（方法）
 - 如果这个属性（方法）是所有的实例共享的，则应该将其保存到类对象中
 - 如果这个属性（方法）是某个实例独有，则应该保存到实例对象中     
    
2. 一般情况下，属性保存到实例对象中
 - 而方法需要保存到类对象中    
```python
# 尝试定义一个表示人的类
class Person :
    # 在类的代码块中，我们可以定义变量和函数
    # 在类中我们所定义的变量，将会成为所有的实例的公共属性
    # 所有实例都可以访问这些变量
    name = 'swk' # 公共属性，所有实例都可以访问

    # 在类中也可以定义函数，类中的定义的函数，我们称为方法
    # 这些方法可以通过该类的所有实例来访问
    
    def say_hello(self) :
        # 方法每次被调用时，解析器都会自动传递第一个实参
        # 第一个参数，就是调用方法的对象本身，
        #   如果是p1调的，则第一个参数就是p1对象
        #   如果是p2调的，则第一个参数就是p2对象
        # 一般我们都会将这个参数命名为self

        # say_hello()这个方法，可以显示如下格式的数据：
        #   你好！我是 xxx
        #   在方法中不能直接访问类中的属性
        print('你好！我是 %s' %self.name)

# 创建Person的实例
p1 = Person()
p2 = Person()

# print(p2.name)

# 调用方法，对象.方法名()
# 方法调用和函数调用的区别
# 如果是函数调用，则调用时传几个参数，就会有几个实参
# 但是如果是方法调用，默认传递一个参数，所以方法中至少要定义一个形参

# 修改p1的name属性
p1.name = '猪八戒'
p2.name = '沙和尚'

p1.say_hello() # '你好！我是 猪八戒'
p2.say_hello() # '你好！我是 沙和尚'

# del p2.name # 删除p2的name属性

# print(p1.name) # swk
# print(p2.name) # 沙和尚
```

### 特殊方法
1. 在类中可以定义一些特殊方法（魔术方法）
2. 特殊方法都是以\_\_开头，\_\_结尾的方法【<font color=red size=3>**双下划线**</font>】
3. 特殊方法不需要我们自己调用，不要尝试去调用特殊方法
4. 特殊方法将会在特殊的时刻自动调用
5. 学习特殊方法：
 - 特殊方法什么时候调用
 - 特殊方法有什么作用

6. _\_init\_\_(self): 初始化方法，对象创建后执行，初始化属性和方法
```python
class Person:
    def __init__(self, name):
        self.name = name

    def say_hello(self):
        print('大家好，我是%s' % self.name)


p1 = Person('孙悟空')
print(p1.say_hello())
```

## 封装
1. 封装指的是隐藏对象中一些不希望被外部所访问到的属性或方法
2. 隐藏对象属性: 属性前加上`__`前缀【<font color=red size=3>**双下划线**</font>】
 - 隐藏属性只能在类的内部访问，无法通过对象访问
 - 实质是将名字修改为了，_类名\_\_属性名 比如 \_\_name -> _Person\_\_name
 - 因此隐藏属性后可以访问改变后的名字就可以在外部访问
3. <font color=red size=3>**一般我们会将一些私有属性（不希望被外部访问的属性）以_开头【单下划线】**</font>
```python
class Person:
    def __init__(self,name):
        self._name = name

    def get_name(self):
        return self._name

    def set_name(self , name):
        self._name = name   

p = Person('孙悟空')

print(p._name) #孙悟空
```
4. property封装器，用来将一个get方法，转换为对象的属性
 - 添加为property装饰器以后，我们就可以像调用属性一样使用get方法
 - 使用property装饰的方法，必须和属性名是一样的
5. setter方法的装饰器：@属性名.setter
```python
class Person:
    def __init__(self,name,age):
        self._name = name
        self._age = age

    @property
    def name(self):
        print('get方法执行了~~~')
        return self._name

    @name.setter
    def name(self , name):
        print('setter方法调用了')
        self._name = name

    @property
    def age(self):
        return self._age

    @age.setter
    def age(self , age):
        self._age = age


p = Person('猪八戒', 18)
p.name = '孙悟空'
p.age = 28
print(p.name, p.age)
```

## 继承
1. 通过继承可以直接让子类获取到父类的方法或属性，避免编写重复性的代码，并且也符合OCP原则
```python
class Animal:
    def run(self):
        print('动物会跑~~~')

    def sleep(self):
        print('动物睡觉~~~')
        
#通过用括号引入父类(Animal)，并覆写父类的方法
class Dog(Animal):
    def bark(self):
        print('汪汪汪~~~') 

    def run(self):
        print('狗跑~~~~')    

#继承父类(Dog)
class Hashiqi(Dog):
    def fan_sha(self):
        print('我是一只傻傻的哈士奇') 
```
2. 在创建类时，如果省略了父类，则默认父类为object
 - object是所有类的父类，所有类都继承自object
```python
class Person(object):
    pass
```
3. issubclass(): 检查一个类是否是另一个类的子类
```python
print(issubclass(Animal , Dog)) #false
print(issubclass(Animal , object)) #true
```
4. isinstance(): 用来检查一个对象是否是一个类的实例
 - 如果这个类是这个对象的父类，也会返回True
 - 所有的对象都是object的实例
```python
print(isinstance(print , object)) #true
```
5. 父类中的所有方法都会被子类继承，包括特殊方法，也可以重写特殊方法
```python
class Animal:
    def __init__(self,name):
        self._name = name

    def run(self):
        print('动物会跑~~~')

    def sleep(self):
        print('动物睡觉~~~')

    @property
    def name(self):
        return self._name

    @name.setter
    def name(self,name):
        self._name = name


class Dog(Animal):

    def __init__(self,name,age):
        # 希望可以直接调用父类的__init__来初始化父类中定义的属性
        # super() 可以用来获取当前类的父类，
        #   并且通过super()返回对象调用父类方法时，不需要传递self
        super().__init__(name)
        self._age = age

    def bark(self):
        print('汪汪汪~~~')

    def run(self):
        print('狗跑~~~~')

    @property
    def age(self):
        return self._age

    @age.setter
    def age(self,age):
        self._age = age

d = Dog('旺财',18)

print(d.name)
print(d.age)
```

6. 多继承: 前边父类的方法会覆盖后边父类的方法
 - 类名.\_\_bases\_\_ 这个属性可以用来获取当前类的所有父类
```python
class C(A,B):
    pass
```


## 多态
- 多态从字面上理解是多种形态
- 狗（狼狗、藏獒、哈士奇、古牧 。。。）
- 一个对象可以以不同的形态去呈现
```python
# 定义一个函数
# 对于say_hello()这个函数来说，只要对象中含有name属性，它就可以作为参数传递
#   这个函数并不会考虑对象的类型，只要有name属性即可
def say_hello(obj):
    print('你好 %s'%obj.name)
```

## 类中的属性和方法
1. 类属性: 直接在类中定义的属性是类属性
 - 类属性可以通过类或类的实例访问到
 - 但是类属性只能通过类对象【<font color=red size=3>**即A.xxx，A是一个类**</font>】来修改，无法通过实例对象修改
2. 实例属性： 通过实例对象添加的属性属于实例属性
 - 实例属性只能通过实例对象来访问和修改，类对象无法访问修改
3. 实例方法：在类中定义，以self为第一个参数的方法都是实例方法
 - 实例方法在调用时，Python会将调用对象作为self传入 
 - 实例方法可以通过实例和类去调用
    - 当通过实例调用时，会自动将当前调用对象作为self传入
    - 当通过类调用时，不会自动传递self，此时我们必须手动传递self
```python
# 定义一个类
class A(object):

    # 类属性
    # 实例属性
    # 类方法
    # 实例方法
    # 静态方法

    # 类属性，直接在类中定义的属性是类属性
    #   类属性可以通过类或类的实例访问到
    #   但是类属性只能通过类对象来修改，无法通过实例对象修改
    count = 0

    def __init__(self):
        # 实例属性，通过实例对象添加的属性属于实例属性
        #   实例属性只能通过实例对象来访问和修改，类对象无法访问修改
        self.name = '孙悟空'

    # 实例方法
    #   在类中定义，以self为第一个参数的方法都是实例方法
    #   实例方法在调用时，Python会将调用对象作为self传入  
    #   实例方法可以通过实例和类去调用
    #       当通过实例调用时，会自动将当前调用对象作为self传入
    #       当通过类调用时，不会自动传递self，此时我们必须手动传递self
    def test(self):
        print('这是test方法~~~ ' , self)    

    # 类方法    
    # 在类内部使用 @classmethod 来修饰的方法属于类方法
    # 类方法的第一个参数是cls，也会被自动传递，cls就是当前的类对象
    #   类方法和实例方法的区别，实例方法的第一个参数是self，而类方法的第一个参数是cls
    #   类方法可以通过类去调用，也可以通过实例调用，没有区别
    @classmethod
    def test_2(cls):
        print('这是test_2方法，他是一个类方法~~~ ',cls)
        print(cls.count)

    # 静态方法
    # 在类中使用 @staticmethod 来修饰的方法属于静态方法  
    # 静态方法不需要指定任何的默认参数，静态方法可以通过类和实例去调用  
    # 静态方法，基本上是一个和当前类无关的方法，它只是一个保存到当前类中的函数
    # 静态方法一般都是一些工具方法，和当前类无关
    @staticmethod
    def test_3():
        print('test_3执行了~~~')


a = A()
# 实例属性，通过实例对象添加的属性属于实例属性
a.count = 10
A.count = 100
print('A ,',A.count) 
print('a ,',a.count) 
print('A ,',A.name) #会报错，没有在该类属性
print('a ,',a.name)   

a.test() #等价于 A.test(a)

A.test_2() #等价于 a.test_2()

A.test_3()
a.test_3()

```

## 垃圾回收
- 就像我们生活中会产生垃圾一样，程序在运行过程当中也会产生垃圾
- 程序运行过程中产生的垃圾会影响到程序的运行的运行性能，所以这些垃圾必须被及时清理
- 没用的东西就是垃圾
- 在程序中没有被引用的对象就是垃圾，这种垃圾对象过多以后会影响到程序的运行的性能
    - 所以我们必须进行及时的垃圾回收，所谓的垃圾回收就是讲垃圾对象从内存中删除
- 在Python中有自动的垃圾回收机制，它会自动将这些没有被引用的对象删除，
    - 所以我们不用手动处理垃圾回收
    
```python
class A:
    def __init__(self):
        self.name = 'A类'

# del是一个特殊方法，它会在对象被垃圾回收前调用
    def __del__(self):
        print('A()对象被删除了~~~',self)

>>> a = A()
>>> a = None # 将a设置为了None，此时没有任何的变量对A()对象进行引用，它就是变成了垃圾
A()对象被删除了~~~ <__main__.A object at 0x000001103EC265F8>

# 又使用一个变量b，来引用a对应的对象,这时A()对象由b进行引用，不是垃圾
>>> a = A()
>>> b = a
>>> a = None
>>> print(a.name)

>>> del b  #手动删除变量b的引用
A()对象被删除了~~~ <__main__.A object at 0x000001103EC265F8>
```

## 特殊方法
1. 特殊方法，也被成为魔法方法
2. 特殊方法都是使用__开头和结尾的
3. 特殊方法一般不需要我们手动调用，需要在一些特殊情况下自动执行

###  \_\_str\_\_()
- 当打印一个对象时，实际上打印的是对象的中特殊方法 \_\_str\_\_()的返回值
-  \_\_str\_\_（）这个特殊方法会在尝试将对象转换为字符串的时候调用
- 它的作用可以用来指定对象转换为字符串的结果  （print函数）
```python
# 定义一个Person类4
>>> class Person(object):
...     def __init__(self, name , age):
...             self.name = name
...             self.age = age
...
>>> p1 = Person('孙悟空',18)
>>> print(p1) #当打印一个对象时，实际上打印的是对象的中特殊方法 __str__()的返回值
<__main__.Person object at 0x000001D1CAAFA160>

#自定义__str__()方法
>>> class Person(object):
...     def __init__(self, name , age):
...             self.name = name
...             self.age = age
...     def __str__(self):
...             return 'Person [name=%s , age=%d]'%(self.name,self.age)
...
>>> p1 = Person('孙悟空',18)
>>> print(p1)
Person [name=孙悟空 , age=18]

```

### \_\repr\_\_()
- 这个特殊方法会在对当前对象使用repr()函数时调用
- 它的作用是指定对象在 ‘交互模式’中直接输出的效果
    - 比如一个变量a = 'hello',如果是print(a)，则调用的是str这个特殊方法，打印hello；
    而如果直接输出a，则调用repr这个特殊方法，打印'hello'
```python
# 在cmd命令行的交互模式下才起作用
>>> a = 'hello'
>>> print(a)
hello
>>> a
'hello'
```

### 其他特殊方法
1. object.\_\_lt\_\_(self, other) 小于 <
2. object.\_\_le\_\_(self, other) 小于等于 <=
3. object.\_\_eq\_\_(self, other) 等于 ==
4. object.\_\_ne\_\_(self, other) 不等于 !=
5. object.\_\_gt\_\_(self, other) 大于 >
```python
>>> class Person(object):
...     def __init__(self, name , age):
...             self.name = name
...             self.age = age
...     def __gt__(self , other):
...             return self.age > other.age
...
>>> p1 = Person('孙悟空',18)
>>> p2 = Person('猪八戒',28)
>>> print(p1 > p2)  #直接使用大于号作比较，其他类似
False
>>> print(p2 > p1)
True
```
6. object.\_\_ge\_\_(self, other) 大于等于 >= 

## 模块（module）
1. 模块化，模块化指将一个完整的程序分解为一个一个小的模块
 - 通过将模块组合，来搭建出一个完整的程序
2. 不采用模块化，统一将所有的代码编写到一个文件中
3. 采用模块化，将程序分别编写到多个文件中
4. 模块化的有点：
 - 方便开发
 - 方便维护
 - 模块可以复用！

5. 在Python中一个py文件就是一个模块，要想创建模块，实际上就是创建一个python文件
 - 注意：模块名要符号标识符的规范

6. 在一个模块中引入外部模块
 - import 模块名 （模块名，就是python文件的名字，注意不要py）
 - import 模块名 as 模块别名
    - 可以引入同一个模块多次，但是模块的实例只会创建一个
    - import可以在程序的任意位置调用，但是一般情况下，import语句都会统一写在程序的开头
    - 在每一个模块内部都有一个\_\_name\_\_属性，通过这个属性可以获取到模块的名字
    - \_\_name\_\_属性值为 \_\_main\_\_的模块是主模块，一个程序中只会有一个主模块
    - <font color=red size=3>**主模块就是我们直接通过 python 执行的模块**</font>

```python
import test_module as test

print(test.__name__)
print(__name__) #当前执行的主程序
```
7. 可以为引入的变量使用别名
- 语法：from 模块名 import 变量 as 别名
- from m import test2 as new_test2

## 包（package）
- 包也是一个模块
- 当我们模块中代码过多时，或者一个模块需要被分解为多个模块时，这时就需要使用到包
- 普通的模块就是一个py文件，而包是一个文件夹
- 包中必须要一个 \_\_init\_\_.py 这个文件，这个文件中可以包含有包中的主要内容

```python
# hello是一个包，也是一个文件夹，包含有__init__.py,a.py,b.py这三个文件，指定引入hello包下的
a模块和b模块
from hello import a , b

print(a.c)
print(b.d)

```
- \_\_pycache\_\_ 是模块的缓存文件
- py代码在执行前，需要被解析器先转换为机器码，然后再执行
- 所以我们在使用模块（包）时，也需要将模块的代码先转换为机器码然后再交由计算机执行
- 而为了提高程序运行的性能，python会在编译过一次以后，将代码保存到一个缓存文件中
- 这样在下次加载这个模块（包）时，就可以不再重新编译而是直接加载缓存中编译好的代码即可

# 第九章 异常和文件
## 异常
### 异常说明
1. 程序在运行过程当中，不可避免的会出现一些错误，比如：
 - 使用了没有赋值过的变量
 - 使用了不存在的索引
 - 除0
 - ...
2. 这些错误在程序中，我们称其为异常。
3. 程序运行过程中，一旦出现异常将会导致程序立即终止，异常以后的代码全部都不会执行！    

### 处理异常
- 程序运行时出现异常，目的并不是让我们的程序直接终止！
- Python是希望在出现异常时，我们可以编写代码来对异常进行处理！    

```python
try语句
    try:
        代码块（可能出现错误的语句）
    except 异常类型 as 异常名:
        代码块（出现错误以后的处理方式）
    except 异常类型 as 异常名:
        代码块（出现错误以后的处理方式）
    except 异常类型 as 异常名:
        代码块（出现错误以后的处理方式）
    else：
        代码块（没出错时要执行的语句）    
    finally:
        代码块（该代码块总会执行）    
```
- try是必须的 else语句有没有都行
- except和finally至少有一个    

- 可以将可能出错的代码放入到try语句，这样如果代码没有错误，则会正常执行，
    - 如果出现错误，则会执行expect子句中的代码，这样我们就可以通过代码来处理异常
    - 避免因为一个异常导致整个程序的终止            

### 异常的传播（抛出异常）
- 当在函数中出现异常时，如果在函数中对异常进行了处理，则异常不会再继续传播,
    - 如果函数中没有对异常进行处理，则异常会继续向函数调用处传播,
    - 如果函数调用处处理了异常，则不再传播，如果没有处理则继续向调用处传播
    - 直到传递到全局作用域（主模块）如果依然没有处理，则程序终止，并且显示异常信息

- 当程序运行过程中出现异常以后，所有的异常信息会被保存一个专门的异常对象中，
    - 而异常传播时，实际上就是异常对象抛给了调用处
    - 比如 ： ZeroDivisionError类的对象专门用来表示除0的异常
        - NameError类的对象专门用来处理变量错误的异常
        - ....

- 在Python为我们提供了多个异常对象            

### 抛出异常
- 可以使用 raise 语句来抛出异常，
    - raise语句后需要跟一个异常类 或 异常的实例
```python
# 也可以自定义异常类，只需要创建一个类继承Exception即可
class MyError(Exception):
    pass

def add(a,b):
    # 如果a和b中有负数，就向调用处抛出异常
    if a < 0 or b < 0:
        # raise用于向外部抛出异常，后边可以跟一个异常类，或异常类的实例
        # raise Exception    
        # 抛出异常的目的，告诉调用者这里调用时出现问题，希望你自己处理一下
        # raise Exception('两个参数中不能有负数！')  
        raise MyError('自定义的异常')
        
        # 也可以通过if else来代替异常的处理
        # return None
    r = a + b
    return r

print(add(-123,456))
```

## 文件（File）
- 通过Python程序来对计算机中的各种文件进行增删改查的操作
- I/O(Input / Output)
- 操作文件的步骤：
 1. 打开文件
 2. 对文件进行各种操作（读、写），然后保存
 3. 关闭文件

### 打开文件（open函数）
- open(file, mode='r', buffering=-1, encoding_=None, errors=None, newline=None, closefd=True, opener=None)
- 使用open函数来打开一个文件
- 参数：
    - file 要打开的文件的名字（路径）
- 返回值：
    - 返回一个对象，这个对象就代表了当前打开的文件

- 创建一个变量，来保存文件的名字
- 如果目标文件和当前文件在同一级目录下，则直接使用文件名即可
```python
file_name = 'demo.txt'

# 在windows系统使用路径时，可以使用/来代替 \
# 或者可以使用 \\ 来代替 \
# 或者也可以使用原始字符串
file_name = 'hello\\demo.txt'
file_name = r'hello\demo.txt'

# 表示路径，可以使用..来返回一级目录
file_name = '../hello/demo.txt'

# 如果目标文件距离当前文件比较远，此时可以使用绝对路径
# 绝对路径应该从磁盘的根目录开始书写
file_name = r'C:\Users\lilichao\Desktop\hello.txt'

file_obj = open(file_name) # 打开 file_name 对应的文件

print(file_obj)
```

### 关闭文件（close函数）
- 当我们获取了文件对象以后，所有的对文件的操作都应该通过对象来进行
- 调用close()方法来关闭文件
- 关闭文件可以提升程序性能，如果有多个进程读取同一个文件不关闭就会在内存中占有多个资源而不被释放
```python
# 打开文件
file_name = 'demo.txt'
file_obj = open(file_name)
# 关闭文件
# 调用close()方法来关闭文件
file_obj.close()
```
- with ... as 语句
    - 在with语句中可以直接使用file_obj来做文件操作
    - 此时这个文件只能在with中使用，一旦with结束则文件会自动close()
```python

#with ... as 语句
with open(file_name) as file_obj :
    # 在with语句中可以直接使用file_obj来做文件操作
    # 此时这个文件只能在with中使用，一旦with结束则文件会自动close()
    print(file_obj.read())
```
    
- try捕获文件找不到问题
```python
file_name = 'hello'

try:
    with open(file_name) as file_obj :
        print(file_obj.read())
except FileNotFoundError:
    print(f'{file_name} 文件不存在~~')
```

### 文件读取
```python
file_name = 'demo2.txt'

try:
    # 调用open()来打开一个文件，可以将文件分成两种类型
    # 一种，是纯文本文件（使用utf-8等编码编写的文本文件）
    # 一种，是二进制文件（图片、mp3、ppt等这些文件）
    # open()打开文件时，默认是以文本文件的形式打开的，但是open()默认的编码为None
    #   所以处理文本文件时，必须要指定文件的编码
    with open(file_name,encoding='utf-8') as file_obj:
        # 通过 read() 来读取文件中的内容
        # 如果直接调用read()它会将文本文件的所有内容全部都读取出来
        #   如果要读取的文件较大的话，会一次性将文件的内容加载到内存中，容易导致内存泄漏
        #   所以对于较大的文件，不要直接调用read()
        
        help(file_obj.read) 帮助信息
        
        # read()可以接收一个size作为参数，该参数用来指定要读取的字符的数量
        #   默认值为-1，它会读取文件中的所有字符
        #   可以为size指定一个值，这样read()会读取指定数量的字符，
        #       每一次读取都是从上次读取到位置开始读取的
        #       如果字符的数量小于size，则会读取剩余所有的
        #       如果已经读取到了文件的最后了，则会返回''空串
        # content = file_obj.read(-1)
        
        content = file_obj.read(6)
        content = file_obj.read(6)
        content = file_obj.read(6)
        content = file_obj.read(6)
        # print(content)
        # print(len(content))
except FileNotFoundError :
    print(f'{file_name} 这个文件不存在！')
```
- 读取大文件的方式
```python
file_name = 'demo.txt'

try:
    with open(file_name,encoding='utf-8') as file_obj:
        # 定义一个变量，来保存文件的内容
        file_content = ''
        # 定义一个变量，来指定每次读取的大小
        chunk = 100
        # 创建一个循环来读取文件内容
        while True:
            # 读取chunk大小的内容
            content = file_obj.read(chunk)

            # 检查是否读取到了内容
            if not content:
                # 内容读取完毕，退出循环
                break

            # 输出内容
            # print(content,end='')
            file_content += content

except FileNotFoundError :
    print(f'{file_name} 这个文件不存在！')


print(file_content)
```
- readline()： 该方法可以用来读取一行内容
- readlines()：该方法用于一行一行的读取内容，它会一次性将读取到的内容封装到一个列表中返回
```python
import pprint
import os
file_name = 'demo.txt'

with open(file_name , encoding='utf-8') as file_obj:
    # readline()
    # 该方法可以用来读取一行内容
    print(file_obj.readline(),end='')
    print(file_obj.readline())
    print(file_obj.readline())

    # readlines()
    # 该方法用于一行一行的读取内容，它会一次性将读取到的内容封装到一个列表中返回
    r = file_obj.readlines()
    pprint.pprint(r[0])
    pprint.pprint(r[1])
    pprint.pprint(r[2])

    #for循环也可以循环每一行读取文件内容
    for t in file_obj:
        print(t)
```

#### 读取二进制文件
- 读取模式
    - t 读取文本文件（默认值）
    - b 读取二进制文件
- 读取文本文件时，size是以字符为单位的
- 读取二进制文件时，size是以字节为单位
```python
file_name = 'c:/Users/lilichao/Desktop/告白气球.flac'


with open(file_name , 'rb') as file_obj:
    # print(file_obj.read(100))

    # 将读取到的内容写出来
    # 定义一个新的文件
    new_name = 'aa.flac'

    with open(new_name , 'wb') as new_obj:

        # 定义每次读取的大小
        chunk = 1024 * 100

        while True :
            # 从已有的对象中读取数据
            content = file_obj.read(chunk)

            # 内容读取完毕，终止循环
            if not content :
                break

            # 将读取到的数据写入到新对象中
            new_obj.write(content)
```

#### 读取文件的位置（seek函数）
- seek()需要两个参数
    - 第一个 是要切换到的位置
    - 第二个 计算位置方式
        - 可选值：
            1. 从头计算，默认值
            2. 从当前位置计算
            3. 从最后位置开始计算
- tell() 方法用来查看当前读取的位置
```python
with open('demo2.txt','rt' , encoding='utf-8') as file_obj:
    # print(file_obj.read(100))
    # print(file_obj.read(30))

    # seek() 可以修改当前读取的位置
    file_obj.seek(9)
    # seek()需要两个参数
    #   第一个 是要切换到的位置
    #   第二个 计算位置方式
    #       可选值：
    #           0 从头计算，默认值
    #           1 从当前位置计算,比如当前读到100，往后再加9个
    #           2 从最后位置开始计算

    print(file_obj.read())

    # tell() 方法用来查看当前读取的位置
    print('当前读取到了 -->',file_obj.tell())
```

### 文件写入（write函数）
```python
file_name = 'demo5.txt'

# 使用open()打开文件时必须要指定打开文件所要做的操作（读、写、追加）
# 如果不指定操作类型，则默认是 读取文件 ， 而读取文件时是不能向文件中写入的
# r 表示只读的
# w 表示是可写的，使用w来写入文件时，如果文件不存在会创建文件，如果文件存在则会截断文件
#   截断文件指删除原来文件中的所有内容
# a 表示追加内容，如果文件不存在会创建文件，如果文件存在则会向文件中追加内容
# x 用来新建文件，如果文件不存在则创建，存在则报错
# + 为操作符增加功能
#   r+ 即可读又可写，文件不存在会报错
#   w+
#   a+
# with open(file_name , 'w' , encoding='utf-8') as file_obj:
# with open(file_name , 'r+' , encoding='utf-8') as file_obj:
with open(file_name , 'x' , encoding='utf-8') as file_obj:
    # write()来向文件中写入内容，
    # 如果操作的是一个文本文件的话，则write()需要传递一个字符串作为参数
    # 该方法会可以分多次向文件中写入内容
    # 写入完成以后，该方法会返回写入的字符的个数
    file_obj.write('aaa\n')
    file_obj.write('bbb\n')
    file_obj.write('ccc\n')
    r = file_obj.write(str(123)+'123123\n')
    r = file_obj.write('今天天气真不错')
    print(r)    #返回写入的字符数
```

### 文件的其他操作
1. os.listdir()： 获取指定目录的目录结构
    - 需要一个路径作为参数，会获取到该路径下的目录结构，默认路径为<font color=black size=4>**.**</font>当前目录
    - 该方法会返回一个列表，目录中的每一个文件（夹）的名字都是列表中的一个元素
2. os.getcwd(): 获取当前所在的目录
3. os.chdir(): 切换当前所在的目录 作用相当于 cd
4. os.mkdir("aaa"): 在当前目录下创建一个名字为 aaa 的目录
5. os.rmdir('abc'): 删除名为abc的目录
6. os.remove('aa.txt'): 删除名为aa.txt的文件
7. os.rename('旧名字','新名字'): 可以对一个文件进行重命名，也可以用来移动一个文件
```python
import os
from pprint import pprint

# os.listdir() 获取指定目录的目录结构
# 需要一个路径作为参数，会获取到该路径下的目录结构，默认路径为 . 当前目录
# 该方法会返回一个列表，目录中的每一个文件（夹）的名字都是列表中的一个元素
r = os.listdir()

# os.getcwd() 获取当前所在的目录
r = os.getcwd()

# os.chdir() 切换当前所在的目录 作用相当于 cd
# os.chdir('c:/')

# r = os.getcwd()

# 创建目录
# os.mkdir("aaa") # 在当前目录下创建一个名字为 aaa 的目录

# 删除目录
# os.rmdir('abc')

# open('aa.txt','w')
# 删除文件
# os.remove('aa.txt')

# os.rename('旧名字','新名字') 可以对一个文件进行重命名，也可以用来移动一个文件
# os.rename('aa.txt','bb.txt')
os.rename('bb.txt','c:/users/lilichao/desktop/bb.txt')

pprint(r)
```