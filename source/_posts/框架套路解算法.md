---
title: 框架套路解算法
date: 2021-01-29 15:37:55
tags: 
- 算法
- 算法框架套路
categories:
- 算法学习
keywords:
- 算法
- 算法框架套路
description: 学习《labuladong的算法小抄》，总结积累，方便温习学习
cover: /2021/01/29/框架套路解算法/框架套路解算法首页.jpg
---

{% note info %}
```Text
--头部属性说明：
title	【必需】文章标题【需要】
date	【必需】文章创建日期【需要】
tags	【可选】文章标签【需要】
categories	【可选】文章分类【需要】
keywords	【可选】文章关键字【需要，同标签】
description	【可选】文章描述【需要】
top_img	【可选】文章顶部图片
cover	【可选】文章缩略图(如果没有设置top_img,文章页顶部将显示缩略图，可设为false/图片地址/留空)【需要，地址为：/年/月/日/文章生成的文件夹名/图片名称.后缀名】
comments	【可选】显示文章评论模块(默认 true)
toc	【可选】显示文章TOC(默认为设置中toc的enable配置)
toc_number	【可选】显示
toc_number	(默认为设置中toc的number配置)
copyright	【可选】显示文章版权模块(默认 true)
mathjax	【可选】显示mathjax(当设置mathjax的per_page: false时，才需要配置，默认 false)
katex	【可选】显示katex(当设置katex的per_page: false时，才需要配置，默认 false)

--标签外挂
样式：
[class] : default | primary | success | info | warning | danger.
{% note info %}
编辑内容
{% endnote %}

--图片插入示例：
不显示描述，可以插入【舍弃不用】：
{% asset_img example.png %}
显示描述的：
![example](example.png)	不用添加路径，直接填图片名称即可，将图片放入对应文件夹内

-- 插入链接
{% link text url [external] [title] %}

--
参考地址：[git 无法添加文件夹下文件](https://www.cnblogs.com/howdop/p/5583342.html)
```
{% endnote %}

# 开篇词
## 目标
1. <font color=red size=3>***可以量化的才叫目标***</font>
{% note primary %}
比如说目标是进大厂，计划半年内刷 300 道题，那这可以反向拆分，每个月刷 50 道，工作日每天刷两道，休息日每天刷一道，再细化，每天几点到几点固定为刷题时间，期间屏蔽所有应用通知，专心做题思考；然后每天反省刷题计划是否达标，如果没达标，是为什么，怎么弥补。

这就是计算机的递归思维，自顶向下，逐步求精，反向求解。我们旧文写了很多动态规划相关的题目，基本都是先写自顶向下的递归解法，然后改写成自底向上的迭代解法，因为递归思路清晰嘛。

<font color=blue size=3>***制定一个计划，而且必须有非常强的坚定意志以及耐心，能够扛得住诱惑经得起枯燥。。。***</font>
{% endnote %}

2. 两点：目标和明白

以下摘抄自算法小抄：
不是说今天热血沸腾给自己制定计划，结果做着做着就被带偏了，真的明白应该是你每时每刻，每分每秒都明白目标是什么。
我指的被带偏不是说学着学着跑去刷抖音了，这种问题可以通过物理隔离等方法避免，我说的带偏是指方向跑偏。
比如说做英语阅读理解，见到一个不认识的词，就去查，这个过程中又见到十个不认识的词，然后又去查，结果一个小时过去了，查了不少单词，但是文章没读几句，题还没做。
你说他没学习，倒也认真学了，但是学着学着方向跑偏了，最后挂科了。
这就是没搞明白目标是啥，这种 DFS 查单词的事情，应该是背单词的时候去做，现在做阅读题呢，目标是快速理解文章内容，选出正确答案嘛。那么几个生僻词汇，影响你对全文内容的掌握吗？
说回学算法，每个人的自身处境不同，需求不同，就应该有不同的学习策略，就像背单词和做阅读两个场景采取两种策略一样。
经常有读者后台留言，让我写一些特别硬核特别难的内容，我都婉言拒绝了；还有的大佬抨击我把算法写成模板是在害人，我也就笑笑不说话。
因为我就很明白咱们讲的这些算法到底是个什么定位，无非就是个锻炼思维能力，准备笔试面试的工具。
需要笔试了，欢迎你来突击学习一下；不需要笔试的话，每天早上地铁上看看，做做思维早操，一天精神好，仅此而已。
大部分读者需要的就是这些，我们号的定位也就是这样。好比初高中的广播体操，就是让学生伸伸胳膊踢踢腿，有益身心健康；你非要说练习后空翻才叫体操，让学生课间练空翻，那估计得出人命了。
从个人的角度，学算法，也要时时刻刻「明白」自己想要的是啥。
如果目标就是从事算法相关的理论研究工作，去啃《算法导论》这种理论性很强的教材完全没问题，反正你还要在学术的路上走很多年，花上一两年打基础性价比挺高。
如果目标是找工作赚钱，那算法就起到个筛选作用，没必要啃大部头，我们号的风格就是你需要的。从各种算法的模板练起，配合历史文章边看边刷，总共可以刷掉将近两百题，国内大厂过算法关没什么问题。节约下来的时间，干点别的不香吗？
说实话我个人更倾向于后者，向钱看齐，那么算法只是个工具。有很多读者纠结于要不要打个竞赛刷个公开课之类的，我觉得大可不必，就好比你跑步，朝着终点直线冲刺最划算，非要跑 S 型秀个蛇皮走位，何苦呢？
人的精力真的是有限的，把每分每秒都压在刀刃上，才能更快达成目标不是么。
当然，不论选择什么，定好目标后都要仔细拆分，严格执行，这个就看个人的执行力了。
本文写了些方法论层面的东西，主要希望大家搞清楚自己学习的目标，制定自己的计划，有自己的思考。不要被乱七八糟的建议牵着鼻子走，今天查一个单词，明天查一个单词，结果到头来挂科了。

# 学习算法和刷题的框架思维
## 数据结构的存储方式
1. <font color=black size=3>***数据结构种类很多，但它们存在的目的都是在不同的应用场景，尽可能高效地增删查改***</font>。最基本的两种存储方式是数组和链表。
2. <font color=red size=3>***数组***</font>：由于是紧凑连续存储,可以随机访问，通过索引快速找到对应元素，而且相对节约存储空间。但正因为连续存储，内存空间必须一次性分配够，所以说数组如果要扩容，需要重新分配一块更大的空间，再把数据全部复制过去，时间复杂度 O(N)；而且你如果想在数组中间进行插入和删除，每次必须搬移后面的所有数据以保持连续，时间复杂度 O(N)。

3. <font color=red size=3>***链表***</font>：因为元素不连续，而是靠指针指向下一个元素的位置，所以不存在数组的扩容问题；如果知道某一元素的前驱和后驱，操作指针即可删除该元素或者插入新元素，时间复杂度 O(1)。但是正因为存储空间不连续，你无法根据一个索引算出对应元素的地址，所以不能随机访问；而且由于每个元素必须存储指向前后元素位置的指针，会消耗相对更多的储存空间。

## 算法刷题指南
1. <font color=black size=3>***先刷二叉树***</font>：因为二叉树是最容易培养框架思维的，而且大部分算法技巧，本质上都是树的遍历问题。
	- 对于一个理解二叉树的人来说，刷一道二叉树的题目花不了多长时间。那么如果你对刷题无从下手或者有畏惧心理，不妨从二叉树下手，前 10 道也许有点难受；结合框架再做 20 道，也许你就有点自己的理解了；刷完整个专题，再去做什么回溯动规分治专题，你就会发现<font color=red size=3>***只要涉及递归的问题，都是树的问题***</font>。

## 总结
1. 数据结构的基本存储方式就是链式和顺序两种，基本操作就是增删查改，遍历方式无非迭代和递归。
2. 刷算法题建议从「树」分类开始刷，结合框架思维，把这几十道题刷完，对于树结构的理解应该就到位了。这时候去看回溯、动规、分治等算法专题，对思路的理解可能会更加深刻一些。

## 推荐书籍
1. 算法 第4版

# 通用解题套路框架
## 动态规划解题套路框架
### 知识储备
1. 动态规划问题的一般形式是求最值，列出`状态转移方程`
2. 求解动态规划的核心问题是穷举，一定会具备`最优子结构`
3. `存在重叠子问题`: 使用“备忘录”或“DP table”
4. 三要素：重叠子问题，最优子结构，状态转移方程

### 套路框架
1. 思维框架：
```shell
明确 base case -> 明确「状态」-> 明确「选择」 -> 定义 dp 数组/函数的含义。
```

2. 通用框架代码
```java
# 初始化 base case
dp[0][0][...] = base
# 进行状态转移
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 求最值(选择1，选择2...)
```

### 举例说明
#### 斐波那契数列
1. 暴力递归
	- `递归算法的时间复杂度等于用子问题个数乘以解决一个子问题需要的时间。`
```java
int fib(int N) {
    if (N == 1 || N == 2) return 1;
    return fib(N - 1) + fib(N - 2);
}
```
![斐波那契数列递归示意图](1、斐波那契数列递归示意图.png)
{% note primary %}
<font color=red size=3>***但凡遇到需要递归的问题，最好都画出递归树，对分析算法的复杂度，寻找算法低效的原因都有巨大帮助。***</font>
{% endnote %}
	- 可以发现，出现重复计算问题，即重叠子问题

2. 带备忘录的递归解法
	- 一般使用一个数组充当这个「备忘录」，可以使用哈希表（字典），思想都是一样的。
```java
int fib(int N) {
    if (N < 1) return 0;
    // 备忘录全初始化为 0
    vector<int> memo(N + 1, 0);
    // 进行带备忘录的递归
    return helper(memo, N);
}

int helper(vector<int>& memo, int n) {
    // base case
    if (n == 1 || n == 2) return 1;
    // 已经计算过
    if (memo[n] != 0) return memo[n];
    memo[n] = helper(memo, n - 1) + helper(memo, n - 2);
    return memo[n];
}
```
![使用备忘录解决重叠子问题](2、使用备忘录解决重叠子问题.png)
![自顶向下求解斐波那契数列](3、自顶向下求解斐波那契数列.png)
	- 子问题个数，即图中节点的总数，由于本算法不存在冗余计算，子问题就是 f(1), f(2), f(3) ... f(20)，数量和输入规模 n = 20 成正比，所以子问题个数为 O(n)。解决一个子问题的时间，同上，没有什么循环，时间为 O(1)。所以，本算法的时间复杂度是 O(n)。比起暴力算法，是降维打击。
	- 带备忘录的递归解法的效率已经和迭代的动态规划解法一样了。实际上，这种解法和迭代的动态规划已经差不多了，只不过这种方法叫做「自顶向下」，动态规划叫做「自底向上」。
3. dp 数组的迭代解法
	- 将备忘录可以进一步独立为一张表：DP table,从而实现自底向上
```java
int fib(int N) {
    if (N < 1) return 0;
    if (N == 1 || N == 2) return 1;
    vector<int> dp(N + 1, 0);
    // base case
    dp[1] = dp[2] = 1;
    for (int i = 3; i <= N; i++)
        dp[i] = dp[i - 1] + dp[i - 2];
    return dp[N];
}
```
![DPTable求解](4、DPTable求解.png)

##### 状态转移方程
1. 描述问题结构的数学形式：
![转移状态方程通用公式](5、转移状态方程通用公式.png)
	- 把 f(n) 想做一个状态 n，这个状态 n 是由状态 n - 1 和状态 n - 2 相加转移而来，这就叫状态转移

2. 上面的几种解法中的所有操作，例如 return f(n - 1) + f(n - 2)，dp[i] = dp[i - 1] + dp[i - 2]，以及对备忘录或 DP table 的初始化操作，都是围绕这个方程式的不同表现形式。可见列出「状态转移方程」的重要性，它是解决问题的核心。而且很容易发现，其实状态转移方程直接代表着暴力解法。
<font color=red size=3>***千万不要看不起暴力解，动态规划问题最困难的就是写出这个暴力解，即状态转移方程。***</font>只要写出暴力解，优化方法无非是用备忘录或者 DP table，再无奥妙可言。

##### 斐波那契数列细节优化
- 根据斐波那契数列的状态转移方程，当前状态只和之前的两个状态有关，其实并不需要那么长的一个 DP table 来存储所有的状态，只要想办法存储之前的两个状态就行了。所以，可以进一步优化，把空间复杂度降为 O(1)：
```java
int fib(int n) {
    if (n < 1) return 0;
    if (n == 2 || n == 1) 
        return 1;
    int prev = 1, curr = 1;
    for (int i = 3; i <= n; i++) {
        int sum = prev + curr;
        prev = curr;
        curr = sum;
    }
    return curr;
}
```
- 以上优化的技巧叫`状态压缩`。如果我们发现每次状态转移只需要 DP table 中的一部分，那么可以尝试用状态压缩来缩小 DP table 的大小，只记录必要的数据，上述例子就相当于把DP table 的大小从 n 缩小到 2。后续的动态规划章节中我们还会看到这样的例子，一般来说是把一个二维的 DP table 压缩成一维，即把空间复杂度从 O(n^2) 压缩到 O(n)。

#### 凑零钱问题
1. 题目
给你 k 种面值的硬币，面值分别为 c1, c2 ... ck，每种硬币的数量无限，再给一个总金额 amount，问你最少需要几枚硬币凑出这个金额，如果不可能凑出，算法返回 -1 。算法的函数签名如下：
```java
// coins 中是可选硬币面值，amount 是目标金额
int coinChange(int[] coins, int amount);
```
比如说 k = 3，面值分别为 1，2，5，总金额 amount = 11。那么最少需要 3 枚硬币凑出，即 11 = 5 + 5 + 1。

2. 暴力递归
	- 这个问题是动态规划问题，因为它具有「最优子结构」的。`要符合「最优子结构」，子问题间必须互相独立`。
	- 什么是相互独立：假设你考试，每门科目的成绩都是互相独立的。你的原问题是考出最高的总成绩，那么你的子问题就是要把语文考到最高，数学考到最高…… 为了每门课考到最高，你要把每门课相应的选择题分数拿到最高，填空题分数拿到最高…… 当然，最终就是你每门课都是满分，这就是最高的总成绩。
	得到了正确的结果：最高的总成绩就是总分。因为这个过程符合最优子结构，“每门科目考到最高”这些子问题是互相独立，互不干扰的。但是，如果加一个条件：你的语文成绩和数学成绩会互相制约，数学分数高，语文分数就会降低，反之亦然。这样的话，显然你能考到的最高总成绩就达不到总分了，按刚才那个思路就会得到错误的结果。因为子问题并不独立，语文数学成绩无法同时最优，所以最优子结构被破坏。
	- <font color=red size=3>***如何列出正确的状态转移方程***</font>？
		- `确定 base case`，这个很简单，显然目标金额 amount 为 0 时算法返回 0，因为不需要任何硬币就已经凑出目标金额了。
		- `确定「状态」，也就是原问题和子问题中会变化的变量。`由于硬币数量无限，硬币的面额也是题目给定的，只有目标金额会不断地向 base case 靠近，所以唯一的「状态」就是目标金额 amount。
		- `确定「选择」，也就是导致「状态」产生变化的行为。`目标金额为什么变化呢，因为你在选择硬币，你每选择一枚硬币，就相当于减少了目标金额。所以说所有硬币的面值，就是你的「选择」。
		- `明确 dp 函数/数组的定义。`我们这里讲的是自顶向下的解法，所以会有一个递归的 dp 函数，一般来说函数的参数就是状态转移中会变化的量，也就是上面说到的「状态」；函数的返回值就是题目要求我们计算的量。就本题来说，状态只有一个，即「目标金额」，题目要求我们计算凑出目标金额所需的最少硬币数量。所以我们可以这样定义 dp 函数：
dp(n) 的定义：输入一个目标金额 n，返回凑出目标金额 n 的最少硬币数量。
搞清楚上面这几个关键点，解法的伪码就可以写出来了：

![example](example.png)
![example](example.png)
![example](example.png)
![example](example.png)
![example](example.png)
![example](example.png)
![example](example.png)
![example](example.png)
![example](example.png)
![example](example.png)
![example](example.png)
![example](example.png)
![example](example.png)
![example](example.png)
![example](example.png)
![example](example.png)
